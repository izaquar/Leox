<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title></title>
<style type="text/css">

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



</style>
</head>
<body>
<div class="document">


<!-- rst3: filename: html\coloring.html -->
<!-- May 2, 2006 -->
<p><a class="reference" href="rstplugin3.html"><img alt="back" src="arrow_lt.gif" /></a> <a class="reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference" href="debuggers.html"><img alt="next" src="arrow_rt.gif" /></a></p>
<div class="section">
<h1><a class="toc-backref" href="#id1" id="chapter-15-controlling-syntax-coloring" name="chapter-15-controlling-syntax-coloring">Chapter 15: Controlling Syntax Coloring</a></h1>
<p>This chapter discusses how to control Leo's new syntax colorer using Python files derived from <a class="reference" href="http://www.jedit.org/">jEdit</a>'s xml language description files.  It also discusses settings related to syntax coloring.</p>
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#chapter-15-controlling-syntax-coloring" id="id1" name="id1">Chapter 15: Controlling Syntax Coloring</a><ul>
<li><a class="reference" href="#files" id="id2" name="id2">Files</a></li>
<li><a class="reference" href="#the-colorizer-s-inner-loop" id="id3" name="id3">The colorizer's inner loop</a></li>
<li><a class="reference" href="#format-of-colorizer-control-files" id="id4" name="id4">Format of colorizer control files</a><ul>
<li><a class="reference" href="#ruleset-names" id="id5" name="id5">Ruleset names</a></li>
<li><a class="reference" href="#x-properties" id="id6" name="id6">x.properties</a></li>
<li><a class="reference" href="#attribute-dictionaries-and-x-attributesdictdict" id="id7" name="id7">Attribute dictionaries and x.attributesDictDict</a></li>
<li><a class="reference" href="#keyword-dictionaries-and-x-keywordsdictdict" id="id8" name="id8">Keyword dictionaries and x.keywordsDictDict</a></li>
<li><a class="reference" href="#rules-rules-dictionaries-and-x-rulesdictdict" id="id9" name="id9">Rules, rules dictionaries and x.rulesDictDict</a></li>
<li><a class="reference" href="#x-importdict-and-imported-versus-delegated-rulesets" id="id10" name="id10">x.importDict and imported versus delegated rulesets</a></li>
</ul>
</li>
<li><a class="reference" href="#rule-methods" id="id11" name="id11">Rule methods</a><ul>
<li><a class="reference" href="#arguments-to-rule-methods" id="id12" name="id12">Arguments to rule methods</a></li>
<li><a class="reference" href="#match-eol-span" id="id13" name="id13">match_eol_span</a></li>
<li><a class="reference" href="#match-eol-span-regexp" id="id14" name="id14">match_eol_span_regexp</a></li>
<li><a class="reference" href="#match-keywords" id="id15" name="id15">match_keywords</a></li>
<li><a class="reference" href="#match-mark-following" id="id16" name="id16">match_mark_following</a></li>
<li><a class="reference" href="#match-mark-previous" id="id17" name="id17">match_mark_previous</a></li>
<li><a class="reference" href="#match-seq" id="id18" name="id18">match_seq</a></li>
<li><a class="reference" href="#match-seq-regexp" id="id19" name="id19">match_seq_regexp</a></li>
<li><a class="reference" href="#match-span" id="id20" name="id20">match_span</a></li>
<li><a class="reference" href="#match-span-regexp" id="id21" name="id21">match_span_regexp</a></li>
<li><a class="reference" href="#match-terminate" id="id22" name="id22">match_terminate</a></li>
</ul>
</li>
<li><a class="reference" href="#code-design-notes" id="id23" name="id23">Code design notes</a><ul>
<li><a class="reference" href="#aha-1-suppress-redraws-until-the-end-of-coloring" id="id24" name="id24">Aha 1:  Suppress redraws until the end of coloring</a></li>
<li><a class="reference" href="#aha-2-always-recolor-at-the-beginning" id="id25" name="id25">Aha 2:  Always recolor at the beginning</a></li>
<li><a class="reference" href="#aha-3-use-quick-coloring-to-eliminate-flash" id="id26" name="id26">Aha 3: Use quick coloring to eliminate flash</a></li>
<li><a class="reference" href="#aha-4-use-character-specific-rules-lists-to-speed-coloring" id="id27" name="id27">Aha 4: Use character-specific rules lists to speed coloring</a></li>
<li><a class="reference" href="#conclusion" id="id28" name="id28">Conclusion</a></li>
</ul>
</li>
<li><a class="reference" href="#syntax-coloring-settings" id="id29" name="id29">Syntax coloring settings</a></li>
</ul>
</li>
</ul>
</div>
<!-- External links... -->
<!-- Relative links... -->
<!-- WARNING: image targets may not have upper case letters! -->
<div class="section">
<h2><a class="toc-backref" href="#id2" id="files" name="files">Files</a></h2>
<p>The <a class="reference" href="http://www.jedit.org/">jEdit</a> editor drives its syntax colorer using xml <strong>language description files.</strong>
<a class="reference" href="http://www.jedit.org/42docs/users-guide/writing-modes-part.html">jEdit's documentation</a> contain a complete description of these xml files.
Each xml file describes one <strong>colorizing mode</strong>.
A mode consists of one or more <strong>rulesets</strong>, and each ruleset consists of a list of <strong>colorizing rules</strong>.
In addition, modes, rulesets and rules may have associated <strong>properties</strong> and <strong>attributes</strong>.
Various rules may specify that the colorizer uses another ruleset (either in the same mode or another mode).</p>
<p><strong>Important</strong>: jEdit's xml language description files contain no explicit <tt class="docutils literal"><span class="pre">&lt;RULE&gt;</span></tt> elements
Rules are simply sub-elements of an enclosing <tt class="docutils literal"><span class="pre">&lt;RULES&gt;</span></tt> element.
The element indicates the kind of rule that is specified,
for example, <tt class="docutils literal"><span class="pre">&lt;SPAN&gt;</span></tt>, <tt class="docutils literal"><span class="pre">&lt;SEQ&gt;</span></tt>, etc.
By the term <strong>rule element</strong> we shall mean any sub-element of the <tt class="docutils literal"><span class="pre">&lt;RULES&gt;</span></tt> element.</p>
<p>Rather than using the xml language description files directly,
Leo uses Python <strong>colorer control files</strong>,
created automatically from the xml files by a script called <tt class="docutils literal"><span class="pre">jEdit2Py</span></tt>.
These Python files contain all the information in the jEdit's xml files,
so we can (loosely) speak of modes, rulesets, rules, properties and attributes in the Python colorer control files.
Later sections of this documentation will make this loose correspondence exact.</p>
<p><strong>Important</strong>: throughout this documentation,
<strong>x.py</strong> will refer to the Python colorer for language <tt class="docutils literal"><span class="pre">x</span></tt>,
and <strong>x.xml</strong> will refer to the corresponding xml language-description file.</p>
<p>Using Python colorer control files has the following advantages:</p>
<ul class="simple">
<li>Running <tt class="docutils literal"><span class="pre">jEdit2Py</span></tt> need only be done when x.xml changes,
and the speed of the xml parser in jEdit2Py does not affect the speed of Leo's colorizer in any way.
Moreover, the <tt class="docutils literal"><span class="pre">jEdit2Py</span></tt> script can contain debugging traces and checks.</li>
<li>Colorer control files are valid .py files, so all of Python's import optimizations work as usual.
In particular, all the data in colorer control files is immediately accessible to Leo's colorer.</li>
<li>Colorer control files are easier for humans to understand and modify than the equivalent xml file.
Furthermore, it is easy to insert debugging information into Python colorer control files.</li>
<li>It is easy to modify the Python colorer control files 'by hand' without changing the corresponding xml file.
In particular, it would be easy to define entirely new kinds of pattern-matching rules in Python merely
by creating functions in a colorer control file.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id3" id="the-colorizer-s-inner-loop" name="the-colorizer-s-inner-loop">The colorizer's inner loop</a></h2>
<p>When Leo's syntax colorer sees the <tt class="docutils literal"><span class="pre">'&#64;language</span> <span class="pre">x'</span></tt> directive,
it will import <tt class="docutils literal"><span class="pre">x.py</span></tt> from Leo's <tt class="docutils literal"><span class="pre">modes</span></tt> folder.
The colorer can then access any module-level object <tt class="docutils literal"><span class="pre">obj</span></tt> in <tt class="docutils literal"><span class="pre">x.py</span></tt> as <tt class="docutils literal"><span class="pre">x.obj</span></tt>.</p>
<p>Colorizer control files contain <strong>rules functions</strong> corresponding to rule elements in x.xml.
The colorizer can call these functions as if they were members of the colorizer class by
passing 'self' as the first argument of these functions.
I call these rules <em>functions</em> to distinguish them from the corresponding
<strong>rules methods</strong> which are actual methods of the colorizer class.
Rules <em>functions</em> merely call corresponding rules <em>methods</em>.
Indeed, rules functions are simply a way of binding values to keyword arguments of rules methods.
These keywords arguments correspond to the xml attributes of rule elements in x.xml.</p>
<p>The colorizer calls rules functions until one matches, at which point a range of text gets colored and the process repeats.
The inner loop of the colorizer is this code:</p>
<pre class="literal-block">
for f in self.rulesDict.get(s[i],[]):
    n = f(self,s,i)
    if n &gt; 0:
        i += n ; break
    else: i += 1
</pre>
<ul class="simple">
<li>rulesDict is a dictionary whose keys are rulesets and whose values are ruleset dictionaries.
Ruleset dictionaries have keys that are single characters and whose values are
the list of rules that can start with that character.</li>
<li>s is the full text to be colorized.</li>
<li>i is the position within s is to be colorized.</li>
</ul>
<p>Rules methods (and functions) return n &gt; 0 if they match, and n == 0 if they fail.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id4" id="format-of-colorizer-control-files" name="format-of-colorizer-control-files">Format of colorizer control files</a></h2>
<p>The following sections describe the top-level data in <tt class="docutils literal"><span class="pre">x.py</span></tt>.</p>
<div class="section">
<h3><a class="toc-backref" href="#id5" id="ruleset-names" name="ruleset-names">Ruleset names</a></h3>
<p>A <strong>ruleset name</strong> is a Python string having the form <tt class="docutils literal"><span class="pre">'x_setname'</span></tt>,
where <tt class="docutils literal"><span class="pre">setname</span></tt> is the value of the <tt class="docutils literal"><span class="pre">SET</span></tt> attribute of the <tt class="docutils literal"><span class="pre">&lt;RULES&gt;</span></tt> element in <tt class="docutils literal"><span class="pre">x.xml</span></tt>.
For example, the ruleset name of the ruleset whose <tt class="docutils literal"><span class="pre">SET</span></tt> attribute is <tt class="docutils literal"><span class="pre">JAVASCRIPT</span></tt> in <tt class="docutils literal"><span class="pre">php.xml</span></tt> is
<tt class="docutils literal"><span class="pre">'php_JAVASCRIPT'</span></tt>.
<strong>Important</strong>: by convention, the ruleset name of the default <tt class="docutils literal"><span class="pre">&lt;RULES&gt;</span></tt> element is <tt class="docutils literal"><span class="pre">'x_main'</span></tt>;
note that default <tt class="docutils literal"><span class="pre">&lt;RULES&gt;</span></tt> element have no <tt class="docutils literal"><span class="pre">SET</span></tt> attributes.</p>
<p>The colorizer uses ruleset names to gain access to all data structures in <tt class="docutils literal"><span class="pre">x.py</span></tt>.
To anticipate a bit, ruleset names are keys into two standard dictionaries,
<tt class="docutils literal"><span class="pre">x.rulesDict</span></tt> and <tt class="docutils literal"><span class="pre">x.keywordsDictDict</span></tt>,
from which the colorizer can get all other information in <tt class="docutils literal"><span class="pre">x.py</span></tt>:</p>
<pre class="literal-block">
# The rules list for the 'JAVASCRIPT' ruleset in php.xml.
rules = x.rulesDict('php_JAVASCRIPT')

# The keywords dict for the 'JAVASCRIPT' ruleset in php.xml.
keywordsDict = x.keywordsDictDict('php_JAVASCRIPT')
</pre>
<p>In fact, ruleset names (and <tt class="docutils literal"><span class="pre">x.rulesDict</span></tt> and <tt class="docutils literal"><span class="pre">x.keywordsDictDict</span></tt>)
are the <strong>only</strong> names that the colorizer needs to know in order to access all information in <tt class="docutils literal"><span class="pre">x.py</span></tt>.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id6" id="x-properties" name="x-properties">x.properties</a></h3>
<p><strong>x.properties</strong> is a Python dictionary corresponding to the &lt;PROPS&gt; element in <tt class="docutils literal"><span class="pre">x.xml</span></tt>.
Keys are property names; values are strings, namely the contents of <tt class="docutils literal"><span class="pre">&lt;PROPERTY&gt;</span></tt> elements in <tt class="docutils literal"><span class="pre">x.xml</span></tt>.
<tt class="docutils literal"><span class="pre">x.properties</span></tt> contains properties for the entire mode.
That is, only modes have <tt class="docutils literal"><span class="pre">&lt;PROPS&gt;</span></tt> elements.
For example, here is <tt class="docutils literal"><span class="pre">x.properties</span></tt> in <tt class="docutils literal"><span class="pre">php.py</span></tt>:</p>
<pre class="literal-block">
# properties for mode php.xml
properties = {
    &quot;commentEnd&quot;: &quot;--&gt;&quot;,
    &quot;commentStart&quot;: &quot;&lt;!--&quot;,
    &quot;indentCloseBrackets&quot;: &quot;}&quot;,
    &quot;indentOpenBrackets&quot;: &quot;{&quot;,
    &quot;lineUpClosingBracket&quot;: &quot;true&quot;,
}
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id7" id="attribute-dictionaries-and-x-attributesdictdict" name="attribute-dictionaries-and-x-attributesdictdict">Attribute dictionaries and x.attributesDictDict</a></h3>
<p><tt class="docutils literal"><span class="pre">x.py</span></tt> contains a <strong>attribute dictionary</strong> for each ruleset in <tt class="docutils literal"><span class="pre">x.xml</span></tt>.
Keys are attribute names, values strings representing the values of the attributes.
This dictionary is empty if a ruleset contains no attributes.
The valid keys are:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">'default'</span></tt>: the default token type.  <tt class="docutils literal"><span class="pre">'null'</span></tt> is the default.</li>
<li><tt class="docutils literal"><span class="pre">'digit_re'</span></tt>: a regular expression.
Words matching this regular expression are colored with the <tt class="docutils literal"><span class="pre">digit</span></tt> token type.</li>
<li><tt class="docutils literal"><span class="pre">'ignore_case'</span></tt>: <tt class="docutils literal"><span class="pre">'true'</span></tt> or <tt class="docutils literal"><span class="pre">'false'</span></tt>.  Default is <tt class="docutils literal"><span class="pre">'true'</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">`highlight_digits'</span></tt>: <tt class="docutils literal"><span class="pre">'true'</span></tt> or <tt class="docutils literal"><span class="pre">'false'</span></tt>.  Default is <tt class="docutils literal"><span class="pre">'true'</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">'no_word_sep'</span></tt>: A list of characters treated as 'alphabetic' characters when matching keywords.</li>
</ul>
<p>For example, here is one attribute dictionary in php.py:</p>
<pre class="literal-block">
# Attributes dict for php_javascript ruleset.
php_javascript_attributes_dict = {
    &quot;default&quot;: &quot;MARKUP&quot;,
    &quot;digit_re&quot;: &quot;&quot;,
    &quot;highlight_digits&quot;: &quot;true&quot;,
    &quot;ignore_case&quot;: &quot;true&quot;,
    &quot;no_word_sep&quot;: &quot;&quot;,
}
</pre>
<p><tt class="docutils literal"><span class="pre">x.py</span></tt> also contains <strong>x.attributesDictDict</strong>.
Keys are ruleset names, values are attribute dictionaries.
Here is <tt class="docutils literal"><span class="pre">attributesDictDict</span></tt> for php.py:</p>
<pre class="literal-block">
# Dictionary of attributes dictionaries for php mode.
attributesDictDict = {
    &quot;php_javascript&quot;: php_javascript_attributes_dict,
    &quot;php_javascript_php&quot;: php_javascript_php_attributes_dict,
    &quot;php_main&quot;: php_main_attributes_dict,
    &quot;php_php&quot;: php_php_attributes_dict,
    &quot;php_php_literal&quot;: php_php_literal_attributes_dict,
    &quot;php_phpdoc&quot;: php_phpdoc_attributes_dict,
    &quot;php_tags&quot;: php_tags_attributes_dict,
    &quot;php_tags_literal&quot;: php_tags_literal_attributes_dict,
}
</pre>
<p><strong>Note</strong>:
The <tt class="docutils literal"><span class="pre">jEdit2Py</span></tt> script creates 'friendly' names for attribute dictionaries <em>solely</em> as an aid for people reading the code.
Leo's colorer uses only the name <tt class="docutils literal"><span class="pre">x.attributeDictDict</span></tt>;
Leo's colorer never uses the actual names of attribute dictionaries.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id8" id="keyword-dictionaries-and-x-keywordsdictdict" name="keyword-dictionaries-and-x-keywordsdictdict">Keyword dictionaries and x.keywordsDictDict</a></h3>
<p><tt class="docutils literal"><span class="pre">x.py</span></tt> contains a <strong>keyword dictionary</strong> for each ruleset in <tt class="docutils literal"><span class="pre">x.xml</span></tt>.
<tt class="docutils literal"><span class="pre">x.py</span></tt> contains an empty keywords dictionary if a ruleset contains no <tt class="docutils literal"><span class="pre">&lt;KEYWORDS&gt;</span></tt> element.</p>
<p>Keys are strings representing keywords of the language describe by the mode.
Values are strings representing syntactic categories,
i.e. a <tt class="docutils literal"><span class="pre">TYPE</span></tt> attribute valid in <tt class="docutils literal"><span class="pre">x.xml</span></tt>, namely:
<tt class="docutils literal"><span class="pre">COMMENT1</span></tt>, <tt class="docutils literal"><span class="pre">COMMENT2</span></tt>, <tt class="docutils literal"><span class="pre">COMMENT3</span></tt>, <tt class="docutils literal"><span class="pre">COMMENT4</span></tt>,
<tt class="docutils literal"><span class="pre">FUNCTION</span></tt>,
<tt class="docutils literal"><span class="pre">KEYWORD1</span></tt>, <tt class="docutils literal"><span class="pre">KEYWORD2</span></tt>, <tt class="docutils literal"><span class="pre">KEYWORD3</span></tt>, <tt class="docutils literal"><span class="pre">KEYWORD4</span></tt>,
<tt class="docutils literal"><span class="pre">LABEL</span></tt>, <tt class="docutils literal"><span class="pre">LITERAL1</span></tt>, <tt class="docutils literal"><span class="pre">LITERAL2</span></tt>, <tt class="docutils literal"><span class="pre">LITERAL3</span></tt>, <tt class="docutils literal"><span class="pre">LITERAL4</span></tt>,
<tt class="docutils literal"><span class="pre">MARKUP</span></tt>, <tt class="docutils literal"><span class="pre">NULL</span></tt> and <tt class="docutils literal"><span class="pre">OPERATOR</span></tt>.</p>
<p>For example, here (parts of) some keyword dictionaries in php.py:</p>
<pre class="literal-block">
# Keywords dict for mode php::PHP
php_PHP_keywords_dict = {
    &quot;COM_invoke&quot;: &quot;keyword2&quot;,
    &quot;COM_load&quot;: &quot;keyword2&quot;,
    &quot;__CLASS__&quot;: &quot;keyword3&quot;,
    ...
    &quot;abs&quot;: &quot;keyword2&quot;,
    &quot;abstract&quot;: &quot;keyword1&quot;,
    &quot;accept_connect&quot;: &quot;keyword2&quot;,
    ...
}

# Keywords dict for mode php::JAVASCRIPT_PHP
php_JAVASCRIPT_PHP_keywords_dict = {}

# Keywords dict for mode php::PHPDOC
php_PHPDOC_keywords_dict = {
    &quot;&#64;abstract&quot;: &quot;label&quot;,
    &quot;&#64;access&quot;: &quot;label&quot;,
    &quot;&#64;author&quot;: &quot;label&quot;,
    ...
    &quot;&#64;var&quot;: &quot;label&quot;,
    &quot;&#64;version&quot;: &quot;label&quot;,
}
</pre>
<p><tt class="docutils literal"><span class="pre">x.py</span></tt> also contains <strong>x.keywordsDictDict</strong>.
Keys are ruleset names, values are keywords dictionaries.
Here is <tt class="docutils literal"><span class="pre">keywordsDictDict</span></tt> for php.py:</p>
<pre class="literal-block">
# Dictionary of keywords dictionaries for php mode.
keywordsDictDict = {
    &quot;php_javascript&quot;: php_javascript_keywords_dict,
    &quot;php_javascript_php&quot;: php_javascript_php_keywords_dict,
    &quot;php_main&quot;: php_main_keywords_dict,
    &quot;php_php&quot;: php_php_keywords_dict,
    &quot;php_php_literal&quot;: php_php_literal_keywords_dict,
    &quot;php_phpdoc&quot;: php_phpdoc_keywords_dict,
    &quot;php_tags&quot;: php_tags_keywords_dict,
    &quot;php_tags_literal&quot;: php_tags_literal_keywords_dict,
}
</pre>
<p>The colorizer can get the keywords dictionary for a ruleset as follows:</p>
<pre class="literal-block">
keywordsDict = x.keywordsDictDict(rulesetName)
</pre>
<p><strong>Note</strong>:
The <tt class="docutils literal"><span class="pre">jEdit2Py</span></tt> script creates 'friendly' names for keyword dictionaries <em>solely</em> as an aid for people reading the code.
Leo's colorer uses only the name <tt class="docutils literal"><span class="pre">x.keywordsDictDict</span></tt>;
Leo's colorer never uses the actual names of keywords dictionaries such as <tt class="docutils literal"><span class="pre">php_PHPDOC_keywords_dict</span></tt>.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id9" id="rules-rules-dictionaries-and-x-rulesdictdict" name="rules-rules-dictionaries-and-x-rulesdictdict">Rules, rules dictionaries and x.rulesDictDict</a></h3>
<p><tt class="docutils literal"><span class="pre">x.py</span></tt> contains one <strong>rule function</strong> for every rule in every ruleset (<tt class="docutils literal"><span class="pre">&lt;RULES&gt;</span></tt> element) in <tt class="docutils literal"><span class="pre">x.xml</span></tt>.
These rules have names <tt class="docutils literal"><span class="pre">rule1</span></tt> through  <tt class="docutils literal"><span class="pre">ruleN</span></tt>,
where <tt class="docutils literal"><span class="pre">N</span></tt> is the total number of rules in all rulesets in <tt class="docutils literal"><span class="pre">x.xml</span></tt>.</p>
<p>Each rules <em>function</em> merely calls a rules <em>method</em> in Leo's colorizer.
Which method gets called depends on the corresponding element in <cite>x.xml</cite>.
For example, the first rule in php.xml is:</p>
<pre class="literal-block">
&lt;SPAN TYPE=&quot;MARKUP&quot; DELEGATE=&quot;PHP&quot;&gt;
            &lt;BEGIN&gt;&amp;lt;?php&lt;/BEGIN&gt;
            &lt;END&gt;?&amp;gt;&lt;/END&gt;
    &lt;/SPAN&gt;
</pre>
<p>and the corresponding rule function is:</p>
<pre class="literal-block">
def php_rule0(colorer, s, i):
    return colorer.match_span(s, i, kind=&quot;markup&quot;, begin=&quot;&lt;?php&quot;, end=&quot;?&gt;&quot;,
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate=&quot;PHP&quot;,exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)
</pre>
<p><tt class="docutils literal"><span class="pre">php_rule0</span></tt> calls <tt class="docutils literal"><span class="pre">colorer.match_span</span></tt> because the corresponding xml rule is a <tt class="docutils literal"><span class="pre">&lt;SPAN&gt;</span></tt> element.</p>
<p>For each ruleset, <tt class="docutils literal"><span class="pre">x.py</span></tt> also contains a <strong>rules dictionary</strong>,
a Python dictionary whose keys are characters and whose values are all lists
of rules functions that that can match the key.
For example:</p>
<pre class="literal-block">
# Rules dict for phpdoc ruleset.
rulesDict8 = {
    &quot;*&quot;: [rule64,],
    &quot;0&quot;: [rule70,],
    &quot;1&quot;: [rule70,],
    &quot;2&quot;: [rule70,],
    &quot;3&quot;: [rule70,],
    &quot;4&quot;: [rule70,],
    &quot;5&quot;: [rule70,],
    &quot;6&quot;: [rule70,],
    &quot;7&quot;: [rule70,],
    &quot;8&quot;: [rule70,],
    &quot;9&quot;: [rule70,],
    &quot;&lt;&quot;: [rule65,rule66,rule67,rule68,rule69,],
    &quot;&#64;&quot;: [rule70,],
    &quot;A&quot;: [rule70,],
    &quot;B&quot;: [rule70,],
    ...
    &quot;X&quot;: [rule70,],
    &quot;Y&quot;: [rule70,],
    &quot;Z&quot;: [rule70,],
    &quot;_&quot;: [rule70,],
    &quot;a&quot;: [rule70,],
    &quot;b&quot;: [rule70,],
   ...
    &quot;x&quot;: [rule70,],
    &quot;y&quot;: [rule70,],
    &quot;z&quot;: [rule70,],
    &quot;{&quot;: [rule63,],
}
</pre>
<p><strong>Note</strong>: The order of rules in each rules list is important;
it should be the same as rules element in <tt class="docutils literal"><span class="pre">x.xml</span></tt>.</p>
<p>Finally, <tt class="docutils literal"><span class="pre">x.py</span></tt> contains <strong>x.rulesDictDict</strong>.
Keys are ruleset names, values are rules dictionaries.
The colorer can get the rules list for character ch as follows:</p>
<pre class="literal-block">
self.rulesDict = x.rulesDictDict.get(rulesetName) # When a mode is inited.
...
rules = sellf.rulesDict.get(ch,[]) # In the main loop.
</pre>
<p>For example, here is the rules dictionary for php.py:</p>
<pre class="literal-block">
# x.rulesDictDict for php mode.
rulesDictDict = {
    &quot;php_javascript&quot;: rulesDict6,
    &quot;php_javascript_php&quot;: rulesDict7,
    &quot;php_main&quot;: rulesDict1,
    &quot;php_php&quot;: rulesDict4,
    &quot;php_php_literal&quot;: rulesDict5,
    &quot;php_phpdoc&quot;: rulesDict8,
    &quot;php_tags&quot;: rulesDict2,
    &quot;php_tags_literal&quot;: rulesDict3,
}
</pre>
<p><strong>Note</strong>:
The <tt class="docutils literal"><span class="pre">jEdit2Py</span></tt> script creates 'friendly' names for rules lists <em>solely</em> as an aid for people reading the code.
Leo's colorer uses only the name <tt class="docutils literal"><span class="pre">x.rulesDictDict</span></tt>;
Leo's colorer never uses the actual names of rules lists such as <tt class="docutils literal"><span class="pre">rulesDict8</span></tt>,
and Leo's colorer never uses the actual names of rules functions such as <tt class="docutils literal"><span class="pre">rule64</span></tt>.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id10" id="x-importdict-and-imported-versus-delegated-rulesets" name="x-importdict-and-imported-versus-delegated-rulesets">x.importDict and imported versus delegated rulesets</a></h3>
<p><tt class="docutils literal"><span class="pre">x.importDict</span></tt> is a Python dictionary.
Keys are ruleset names; values are a list of ruleset names.
For example:</p>
<pre class="literal-block">
# Import dict for php mode.
importDict = {
    &quot;php_javascript_php&quot;: [&quot;javascript::main&quot;],
}
</pre>
<p>For any ruleset <tt class="docutils literal"><span class="pre">R</span></tt> whose ruleset name is <tt class="docutils literal"><span class="pre">N</span></tt>, <tt class="docutils literal"><span class="pre">x.importDict.get(N)</span></tt>
is the list of rulesets names whose rulesets appear in
a <tt class="docutils literal"><span class="pre">DELEGATE</span></tt> attribute of an <tt class="docutils literal"><span class="pre">&lt;IMPORT&gt;</span></tt> rule element in <tt class="docutils literal"><span class="pre">R's</span></tt> ruleset.
Such <strong>imported</strong> ruleset are copied to the end of the <tt class="docutils literal"><span class="pre">R's</span></tt> rules list.
Leo's colorizer does this copying only once, when loading ruleset <tt class="docutils literal"><span class="pre">R</span></tt> for the first time.</p>
<p><strong>Note 1</strong>: Loading imported rulesets must be done at 'run time'.
It should definitely not be done by <tt class="docutils literal"><span class="pre">jEdit2Py</span></tt> at 'compile time';
that would require running <tt class="docutils literal"><span class="pre">jEdit2Py</span></tt> on <em>all</em> .xml files whenever any such file changed.</p>
<p><strong>Note 2</strong>:  Multiple <tt class="docutils literal"><span class="pre">&lt;IMPORT&gt;</span></tt> rule elements in a single ruleset are allowed:
delegated rules are copied to the end of <tt class="docutils literal"><span class="pre">N's</span></tt> rules list in the order they appear in the ruleset.</p>
<p><strong>Note 3</strong>: The <tt class="docutils literal"><span class="pre">DELEGATE</span></tt> attribute of <tt class="docutils literal"><span class="pre">&lt;IMPORT&gt;</span></tt> elements is, in fact,
completely separate from the <tt class="docutils literal"><span class="pre">DELEGATE</span></tt> attributes of other rules as
discussed in <a class="reference" href="#arguments-to-rule-methods">Arguments to rule methods</a>.
Indeed, the <tt class="docutils literal"><span class="pre">DELEGATE</span></tt> attribute of <tt class="docutils literal"><span class="pre">&lt;IMPORT&gt;</span></tt> elements creates entries in
<tt class="docutils literal"><span class="pre">x.importDict</span></tt>, which in turn causes the colorizer to append the rules of the imported ruleset
to the end of the present rules list.
In contrast, the <tt class="docutils literal"><span class="pre">DELEGATE</span></tt> attributes of other rules sets the <tt class="docutils literal"><span class="pre">delegate</span></tt> argument to rules methods,
which in tern causes the colorizer to recursively color the matched text with the <strong>delegated</strong> ruleset.
In short:</p>
<ul class="simple">
<li>The rules of <strong>imported</strong> rulesets are appended to the end of another rules list;
the rules of <strong>delegated</strong> rulesets never are.</li>
<li><strong>Imported</strong> ruleset names appear as the values of items in <tt class="docutils literal"><span class="pre">x.importDict</span></tt>;
<strong>delegated</strong> ruleset names appear as <tt class="docutils literal"><span class="pre">delegate</span></tt> arguments to rule methods.</li>
</ul>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id11" id="rule-methods" name="rule-methods">Rule methods</a></h2>
<p>This section describes each rules method in Leo's new colorizer.
Rules methods are called by rules functions in colorizer control file;
they correspond directly to rules elements in jEdit's language description files.
In fact, this documentation is a 'refactoring' of <a class="reference" href="http://www.jedit.org/42docs/users-guide/writing-modes-part.html">jEdit's documentation</a>.</p>
<p>All rule methods attempt to match a pattern at a particular spot in a string.
These methods all return True if the match succeeds.</p>
<div class="section">
<h3><a class="toc-backref" href="#id12" id="arguments-to-rule-methods" name="arguments-to-rule-methods">Arguments to rule methods</a></h3>
<p>All rule methods take three required arguments and zero or more optional keyword arguments.</p>
<p>Here is a list of the required arguments and their meaning:</p>
<ul class="simple">
<li><strong>self</strong>: An instance of Leo's colorizer.</li>
<li><strong>s</strong>: The string in which matches may be found.</li>
<li><strong>i</strong>: The location within the string at which the rule method looks for a match.</li>
</ul>
<p>Here is a list of all optional keyword arguments and their meaning:</p>
<ul class="simple">
<li><strong>at_line_start</strong>:
If <tt class="docutils literal"><span class="pre">True</span></tt>, a match will succeed only if <tt class="docutils literal"><span class="pre">i</span></tt> is at the start of a line.</li>
<li><strong>at_whitespace_end</strong>:
If <tt class="docutils literal"><span class="pre">True</span></tt>, the match will succeed only if <tt class="docutils literal"><span class="pre">i</span></tt> is at the first non-whitespace text in a line.</li>
<li><strong>at_word_start</strong>:
If <tt class="docutils literal"><span class="pre">True</span></tt>, the match will succeed only if <tt class="docutils literal"><span class="pre">i</span></tt> is at the beginning of a word.</li>
<li><strong>delegate</strong>:
If non-empty, the value of this argument is a <a class="reference" href="#ruleset-names">ruleset name</a>.
If the match succeeds, the matched text will be colored recursively with the indicate ruleset.</li>
<li><strong>exclude_match</strong>:
If <tt class="docutils literal"><span class="pre">True</span></tt>, the actual text that matched will not be colored.
The meaning of this argument varies slightly depending on whether one or two sequences are matched.
See the individual rule methods for details.</li>
<li><strong>kind</strong>: A string representing a class of tokens, i.e., one of:
<tt class="docutils literal"><span class="pre">'comment1'</span></tt>, <tt class="docutils literal"><span class="pre">'comment2'</span></tt>, <tt class="docutils literal"><span class="pre">'comment3'</span></tt>, <tt class="docutils literal"><span class="pre">'comment4'</span></tt>, <tt class="docutils literal"><span class="pre">'function'</span></tt>,
<tt class="docutils literal"><span class="pre">'keyword1'</span></tt>, <tt class="docutils literal"><span class="pre">'keyword2'</span></tt>, <tt class="docutils literal"><span class="pre">'keyword3'</span></tt>, <tt class="docutils literal"><span class="pre">'keyword4'</span></tt>,
<tt class="docutils literal"><span class="pre">'label'</span></tt>, <tt class="docutils literal"><span class="pre">'literal1'</span></tt>, <tt class="docutils literal"><span class="pre">'literal2'</span></tt>, <tt class="docutils literal"><span class="pre">'literal3'</span></tt>, <tt class="docutils literal"><span class="pre">'literal4'</span></tt>,
<tt class="docutils literal"><span class="pre">'markup'</span></tt>, <tt class="docutils literal"><span class="pre">'null'</span></tt> and <tt class="docutils literal"><span class="pre">'operator'</span></tt>.</li>
<li><strong>no_escape</strong>:
If <tt class="docutils literal"><span class="pre">True</span></tt>, the ruleset's escape character will have no effect before the <tt class="docutils literal"><span class="pre">end</span></tt> argument to <tt class="docutils literal"><span class="pre">match_span</span></tt>.
Otherwise, the presence of the escape character will cause that occurrence of the end string to be ignored.</li>
<li><strong>no_line_break</strong>:
If <tt class="docutils literal"><span class="pre">True</span></tt>, the match will not succeed across line breaks.</li>
<li><strong>no_word_break</strong>:
If <tt class="docutils literal"><span class="pre">True</span></tt>, the match will not cross word breaks.</li>
</ul>
<p>New in Leo 4.4.1 final: the regular expression rule matchers no longer get a <tt class="docutils literal"><span class="pre">hash_char</span></tt> argument
because such matchers are called only if the present search pattern starts with <tt class="docutils literal"><span class="pre">hash_char</span></tt>.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id13" id="match-eol-span" name="match-eol-span">match_eol_span</a></h3>
<pre class="literal-block">
def match_eol_span (self,s,i,kind,begin,
    at_line_start = False,
    at_whitespace_end = False,
    at_word_start = False,
    delegate = '',
    exclude_match = False):
</pre>
<p><tt class="docutils literal"><span class="pre">match_eol_span</span></tt> succeeds if <tt class="docutils literal"><span class="pre">s[i:].startswith(begin)</span></tt> and
the <tt class="docutils literal"><span class="pre">at_line_start</span></tt>, <tt class="docutils literal"><span class="pre">at_whitespace_end</span></tt> and <tt class="docutils literal"><span class="pre">at_word_start</span></tt> conditions are all satisfied.</p>
<p>If successful, <tt class="docutils literal"><span class="pre">match_eol_span</span></tt> highlights from i to the end of the line
with the color specified by <tt class="docutils literal"><span class="pre">kind</span></tt>.
If the <tt class="docutils literal"><span class="pre">exclude_match</span></tt> argument is <tt class="docutils literal"><span class="pre">True</span></tt>, only the text before the matched text will be colored.
The <tt class="docutils literal"><span class="pre">delegate</span></tt> argument, if present, specifies the ruleset to color the colored text.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id14" id="match-eol-span-regexp" name="match-eol-span-regexp">match_eol_span_regexp</a></h3>
<pre class="literal-block">
def match_eol_span_regexp (self,s,i,kind,regex,
    at_line_start = False,
    at_whitespace_end = False,
    at_word_start = False,
    delegate = '',
    exclude_match = False):
</pre>
<p><tt class="docutils literal"><span class="pre">match_eol_span_exp</span></tt> succeeds if:</p>
<ol class="arabic simple">
<li>The regular expression <tt class="docutils literal"><span class="pre">regex</span></tt> matches at <tt class="docutils literal"><span class="pre">s[i:]</span></tt>, and</li>
<li>The <tt class="docutils literal"><span class="pre">at_line_start</span></tt>, <tt class="docutils literal"><span class="pre">at_whitespace_end</span></tt> and <tt class="docutils literal"><span class="pre">at_word_start</span></tt> conditions are all satisfied.</li>
</ol>
<p>If successful, <tt class="docutils literal"><span class="pre">match_eol_span_regexp</span></tt>  highlights from i to the end of the line.
If the <tt class="docutils literal"><span class="pre">exclude_match</span></tt> argument is <tt class="docutils literal"><span class="pre">True</span></tt>, only the text before the matched text will be colored.
The <tt class="docutils literal"><span class="pre">delegate</span></tt> argument, if present, specifies the ruleset to color the colored text.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id15" id="match-keywords" name="match-keywords">match_keywords</a></h3>
<pre class="literal-block">
def match_keywords (self,s,i):
</pre>
<p><tt class="docutils literal"><span class="pre">match_keywords</span></tt> succeeds if <tt class="docutils literal"><span class="pre">s[i:]</span></tt> starts with an identifier contained in the mode's keywords dictionary <tt class="docutils literal"><span class="pre">d</span></tt>.</p>
<p>If successful, <tt class="docutils literal"><span class="pre">match_keywords</span></tt> colors the keyword.
<tt class="docutils literal"><span class="pre">match_keywords</span></tt> does not take a <tt class="docutils literal"><span class="pre">kind</span></tt> keyword argument.
Instead, the keyword is colored as specified by <tt class="docutils literal"><span class="pre">d.get(theKeyword)</span></tt>.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id16" id="match-mark-following" name="match-mark-following">match_mark_following</a></h3>
<pre class="literal-block">
def match_mark_following (self,s,i,kind,pattern,
    at_line_start = False,
    at_whitespace_end = False,
    at_word_start = False,
    exclude_match = False):
</pre>
<p>match_mark_following succeeds if s[i:].startswith(pattern), and
the <tt class="docutils literal"><span class="pre">at_line_start</span></tt>, <tt class="docutils literal"><span class="pre">at_whitespace_end</span></tt> and <tt class="docutils literal"><span class="pre">at_word_start</span></tt> conditions are all satisfied.</p>
<p>If successful, <tt class="docutils literal"><span class="pre">match_mark_following</span></tt> colors from <tt class="docutils literal"><span class="pre">i</span></tt> to the start of the next token
with the color specified by <tt class="docutils literal"><span class="pre">kind</span></tt>.
If the <tt class="docutils literal"><span class="pre">exclude_match</span></tt> argument is <tt class="docutils literal"><span class="pre">True</span></tt>, only the text after the matched text will be colored.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id17" id="match-mark-previous" name="match-mark-previous">match_mark_previous</a></h3>
<pre class="literal-block">
def match_mark_previous (self,s,i,kind,pattern,
    at_line_start = False,
    at_whitespace_end = False,
    at_word_start = False,
    exclude_match = False):
</pre>
<p><tt class="docutils literal"><span class="pre">match_mark_previous</span></tt> succeeds if s[i:].startswith(pattern),and
the <tt class="docutils literal"><span class="pre">at_line_start</span></tt>, <tt class="docutils literal"><span class="pre">at_whitespace_end</span></tt> and <tt class="docutils literal"><span class="pre">at_word_start</span></tt> conditions are all satisfied.</p>
<p>If successful, <tt class="docutils literal"><span class="pre">match_mark_previous</span></tt> colors from the end of the previous token to <tt class="docutils literal"><span class="pre">i</span></tt>
with the color specified by <tt class="docutils literal"><span class="pre">kind</span></tt>.
If the <tt class="docutils literal"><span class="pre">exclude_match</span></tt> argument is <tt class="docutils literal"><span class="pre">True</span></tt>, only the text before the matched text will be colored.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id18" id="match-seq" name="match-seq">match_seq</a></h3>
<pre class="literal-block">
def match_seq (self,s,i,kind,seq,
    at_line_start = False,
    at_whitespace_end = False,
    at_word_start = False,
    delegate = ''):
</pre>
<p><tt class="docutils literal"><span class="pre">match_seq</span></tt> succeeds if <tt class="docutils literal"><span class="pre">s[i:].startswith(seq)</span></tt> and
the <tt class="docutils literal"><span class="pre">at_line_start</span></tt>, <tt class="docutils literal"><span class="pre">at_whitespace_end</span></tt> and <tt class="docutils literal"><span class="pre">at_word_start</span></tt> conditions are all satisfied.</p>
<p>If successful, <tt class="docutils literal"><span class="pre">match_seq</span></tt> highlights from <tt class="docutils literal"><span class="pre">i</span></tt> to the end of the sequence
with the color specified by <tt class="docutils literal"><span class="pre">kind</span></tt>.
The <tt class="docutils literal"><span class="pre">delegate</span></tt> argument, if present, specifies the ruleset to color the colored text.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id19" id="match-seq-regexp" name="match-seq-regexp">match_seq_regexp</a></h3>
<pre class="literal-block">
def match_seq_regexp (self,s,i,kind,regex,
    at_line_start = False,
    at_whitespace_end = False,
    at_word_start = False,
    delegate = ''):
</pre>
<p><tt class="docutils literal"><span class="pre">match_seq</span></tt> succeeds if:</p>
<ol class="arabic simple">
<li>The regular expression <tt class="docutils literal"><span class="pre">regex</span></tt> matches at <tt class="docutils literal"><span class="pre">s[i:]</span></tt>, and</li>
<li>The <tt class="docutils literal"><span class="pre">at_line_start</span></tt>, <tt class="docutils literal"><span class="pre">at_whitespace_end</span></tt> and <tt class="docutils literal"><span class="pre">at_word_start</span></tt> conditions are all satisfied.</li>
</ol>
<p>If successful, <tt class="docutils literal"><span class="pre">match_seq_regexp</span></tt> highlights from <tt class="docutils literal"><span class="pre">i</span></tt> to the end of the sequence
with the color specified by <tt class="docutils literal"><span class="pre">kind</span></tt>.
The <tt class="docutils literal"><span class="pre">delegate</span></tt> argument, if present, specifies the ruleset to color the colored text.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id20" id="match-span" name="match-span">match_span</a></h3>
<pre class="literal-block">
def match_span (self,s,i,kind,begin,end,
    at_line_start = False,
    at_whitespace_end = False,
    at_word_start = False,
    exclude_match = False,
    delegate = ''
    no_escape = False,
    no_line_break = False,
    no_word_break = False):
</pre>
<p><tt class="docutils literal"><span class="pre">match_span</span></tt> succeeds if there is an index <tt class="docutils literal"><span class="pre">j</span> <span class="pre">&gt;</span> <span class="pre">i</span></tt> such that
<tt class="docutils literal"><span class="pre">s[:i].startswith(begin)</span></tt> and <tt class="docutils literal"><span class="pre">s[i:j].endswith(end)</span></tt> and the
<tt class="docutils literal"><span class="pre">at_line_start</span></tt>, <tt class="docutils literal"><span class="pre">at_whitespace_end</span></tt>, <tt class="docutils literal"><span class="pre">at_word_start</span></tt>,
<tt class="docutils literal"><span class="pre">no_escape</span></tt>, <tt class="docutils literal"><span class="pre">no_line_break</span></tt> and <tt class="docutils literal"><span class="pre">no_word_break</span></tt> conditions are all satisfied.</p>
<p>If successful, <tt class="docutils literal"><span class="pre">match_span</span></tt> highlights from <tt class="docutils literal"><span class="pre">s[i:j</span></tt>
with the color specified by <tt class="docutils literal"><span class="pre">kind</span></tt>;
but if the <tt class="docutils literal"><span class="pre">exclude_match</span></tt> argument is <tt class="docutils literal"><span class="pre">True</span></tt>, the <tt class="docutils literal"><span class="pre">begin</span></tt> and <tt class="docutils literal"><span class="pre">end</span></tt> text are not colored.
The <tt class="docutils literal"><span class="pre">delegate</span></tt> argument, if present, specifies the ruleset to color the colored text.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id21" id="match-span-regexp" name="match-span-regexp">match_span_regexp</a></h3>
<pre class="literal-block">
def match_span (self,s,i,kind,regex,end,
    at_line_start = False,
    at_whitespace_end = False,
    at_word_start = False,
    exclude_match = False,
    delegate = ''
    no_escape = False,
    no_line_break = False,
    no_word_break = False):
</pre>
<p><tt class="docutils literal"><span class="pre">match_span_regex</span></tt> succeeds if:</p>
<ol class="arabic simple">
<li>The regular expression <tt class="docutils literal"><span class="pre">regex</span></tt> matches at <tt class="docutils literal"><span class="pre">s[i:]</span></tt>,</li>
<li>There is an index <tt class="docutils literal"><span class="pre">j</span> <span class="pre">&gt;</span> <span class="pre">i</span></tt> such that <tt class="docutils literal"><span class="pre">s[i:j].endswith(end)</span></tt>,</li>
<li>The <tt class="docutils literal"><span class="pre">at_line_start</span></tt>, <tt class="docutils literal"><span class="pre">at_whitespace_end</span></tt>, <tt class="docutils literal"><span class="pre">at_word_start</span></tt>,
<tt class="docutils literal"><span class="pre">no_escape</span></tt>, <tt class="docutils literal"><span class="pre">no_line_break</span></tt> and <tt class="docutils literal"><span class="pre">no_word_break</span></tt> conditions are all satisfied.</li>
</ol>
<p>If successful, <tt class="docutils literal"><span class="pre">match_span</span></tt> colors <tt class="docutils literal"><span class="pre">s[i:j]</span></tt>,
with the color specified by <tt class="docutils literal"><span class="pre">kind</span></tt>;
but if the <tt class="docutils literal"><span class="pre">exclude_match</span></tt> argument is <tt class="docutils literal"><span class="pre">True</span></tt>, the <tt class="docutils literal"><span class="pre">begin</span></tt> and <tt class="docutils literal"><span class="pre">end</span></tt> text are not colored.
The <tt class="docutils literal"><span class="pre">delegate</span></tt> argument, if present, specifies the ruleset to color the colored text.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id22" id="match-terminate" name="match-terminate">match_terminate</a></h3>
<pre class="literal-block">
def match_terminate (self,s,i,kind,at_char):
</pre>
<p><tt class="docutils literal"><span class="pre">match_terminate</span></tt> succeeds if <tt class="docutils literal"><span class="pre">s[i:]</span></tt> contains at least <tt class="docutils literal"><span class="pre">at_char</span></tt> more characters.</p>
<p>If successful, <tt class="docutils literal"><span class="pre">match_terminate</span></tt> colors <tt class="docutils literal"><span class="pre">at_char</span></tt> characters
with the color specified by <tt class="docutils literal"><span class="pre">kind</span></tt>.</p>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id23" id="code-design-notes" name="code-design-notes">Code design notes</a></h2>
<p>This rest of this chapter tells how the new colorizer works in detail.
It is organized around several design principles.
I call them aha's because that was what they were at the time.</p>
<div class="section">
<h3><a class="toc-backref" href="#id24" id="aha-1-suppress-redraws-until-the-end-of-coloring" name="aha-1-suppress-redraws-until-the-end-of-coloring">Aha 1:  Suppress redraws until the end of coloring</a></h3>
<p>This was the big breakthrough because it provided a clear, direct, predictable way of controlling the colorizing process.</p>
<p>Tk doesn't provide a high-level way of discovering whether events are pending, so to provide good key-handling response the colorizer must pause regularly.  The colorizer pauses by queuing itself as an idle-time event. <strong>Drawing must not happen during this idle time</strong>.  In that case, idle time will happen 'quickly' and the colorizer will resume without perceptible delay. Tests show that colorizing can be interrupted hundreds of times without noticeable delay <em>provided</em> that nothing major happens during idle time.</p>
<p>Suppressing redraws is easy.  Rather than calling Tk's tag_remove and tag_add methods directly during coloring, the colorizer simply adds the range of text to be colored to a list.  When colorizing is complete, the colorizer simply removes all tags en masse and then calls tag_add.</p>
<p>We can now begin to see now why using separate threads would just confuse matters.  Pausing regularly is a simple, explicit way of giving up control.  Threads can not do better.  You might want to consider how the following discussions would be complicated if multiple threads were involved.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id25" id="aha-2-always-recolor-at-the-beginning" name="aha-2-always-recolor-at-the-beginning">Aha 2:  Always recolor at the beginning</a></h3>
<p>Leo's old colorizer was a marvel of effort designed to reduce the number of time spent in the colorizer.  Alas, this code was complex and error prone.  Worse, bugs caused text to be incorrectly colored.  It turns out that this effort was not needed.</p>
<p>Aha 1 tells us that the main colorizer loop will be very fast <em>until</em> another event happens.  Whenever the text to be colored changes (for whatever reason) a request to recolor the text will be issued.  When that happens the new colorizer always <strong>aborts</strong> any previous colorizing and restarts colorizing at the beginning.</p>
<p>The aha is, in effect, that 'throwing away' the previous colorizing work is <em>not</em> a wasteful strategy.  Indeed, because of Aha 1, restarting at the beginning has no effect on response time.  The colorizer pauses regularly regardless of how much colorizing happens. So any 'wasted' effort could only effect the <em>total</em> time to colorize the text, not the response time.  But in the typical, most important case, the only character that actually has to be colored is the characters just typed, and in that case <em>it doesn't matter</em> how long it takes to recolor the other characters because (usually) their colors won't change!</p>
<p>Ok you say, but what about the characters just typed?  Won't restarting the colorizing at the beginning slow down the colorizing of the characters being typed?  Yes, it would, without the next Aha.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id26" id="aha-3-use-quick-coloring-to-eliminate-flash" name="aha-3-use-quick-coloring-to-eliminate-flash">Aha 3: Use quick coloring to eliminate flash</a></h3>
<p>Restarting coloring at the beginning is an optimal strategy, <em>provided</em> that the character just typed (call it <strong>ch</strong>) can be colored quickly.  And make no mistake, colorizing ch is important, otherwise it flashes: first ch is colored black, and a few tenths of a second later ch turns to its final color.  Such flash is most annoying, and we want to eliminate it as much as possible.</p>
<p>The Aha is that flash doesn't matter if it happens infrequently.  That is, the colorizer does <em>not</em> have to do a perfect job of colorizing the character just typed.  Instead, the colorizer can 'guess' what the proper color for ch should be, and if that guess turns out to be incorrect the main colorizer loop will color ch correctly later.  If, once in a great while, the colorizer guesses wrong the flash will be largely unnoticed.</p>
<p>Quick coloring is a prepass, independent of the colorizer's main loop.  Quick coloring makes its best guess about what the color ch should be.  This guess could be wrong, but to repeat, mistakes will be corrected later by the main colorizing loop.</p>
<p>Quick coloring uses heuristics to make guesses.  The simplest heuristic is to give ch the color of the previous character.  This guess will be correct except at the boundaries of tokens, for example, if ch follows the end of a string or comment.  Note that we can ignore mistakes caused by large-scale text changes, such as cutting and pasting text, because such operations happen infrequently and because so much else is changing that temporarily incorrect colors don't matter.</p>
<p>So we need better heuristics only for changes to a single character, ch. In that case, mistakes can happen only at the boundaries of tokens.  Here is the plan: the main coloring loop will create a dict whose keys are locations in the (previous) text and whose values are the starting location of the token that caused each location to be colored.  Quick coloring will then do a 'trial' coloring starting at the start of the token that <em>previously</em> caused ch to be colored.  The correct color for ch will be known for certain if the trial coloring includes ch.  I have not implemented this heuristic yet, but I am reasonably confident that it will eliminate all (or almost all) mistakes when typing single characters.</p>
<p>Quick coloring is sweet.  It gives almost all the advantages of incremental coloring with no significant impact on the rest of the colorizer.  Quick coloring does not have to be perfect to be supremely useful because the main colorizing loop will always (eventually, in its brute-force way) color every single character correctly.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id27" id="aha-4-use-character-specific-rules-lists-to-speed-coloring" name="aha-4-use-character-specific-rules-lists-to-speed-coloring">Aha 4: Use character-specific rules lists to speed coloring</a></h3>
<p>The first draft of the main colorizer loop tried every rule for every character.
We can do much better than that because the jEdit rules require that each rule can only match patterns that start with a single character.
Using Python mode as an example, rather than searching through a list of 23 rules,
the character-specific rules lists have one or two items, and many rule lists are empty.</p>
<p>jEdit2Py now creates x.rulesDictDict in every x.py file.
Keys are rulesets.  Values are ruleset dictionaries.
Ruleset dictionaries have keys that are single characters and whose values are the list of rules that can start with that character. So the colorizer's inner loop is now:</p>
<pre class="literal-block">
for f in self.rulesDict.get(s[i],[]):
    n = f(self,s,i)
    if n &gt; 0:
        i += n ; break
    else: i += 1
</pre>
<p>This is as good as it gets.
It is significantly, noticeably, faster than using a single rules list for each ruleset.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id28" id="conclusion" name="conclusion">Conclusion</a></h3>
<p>The new colorizer is a great success:</p>
<ul class="simple">
<li>It is simple where it must be perfect, and complex only where mistakes are harmless.</li>
<li>It guarantees excellent response time without using threads.</li>
<li>It colors text essentially as fast as possible.</li>
<li>It eliminates flash almost all the time.</li>
<li>It is self contained and is almost completely independent of Leo.</li>
<li>It is largely independent of Tk, and might be even simpler in other environments.</li>
<li>The distinction between incremental and non-incremental coloring no longer exists.</li>
<li>Client code need do nothing special to support the colorizer, a major simplification.</li>
</ul>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id29" id="syntax-coloring-settings" name="syntax-coloring-settings">Syntax coloring settings</a></h2>
<p>This section discusses only those settings that affect syntax coloring.
See <a class="reference" href="customizing.html">Chapter 8</a> for a general discussion of Leo's settings.</p>
<p>Both the old colorizer (in Leo's core) and the new colorizer (the __jEdit_colorizer plugin)
now support &#64;font settings for colorizing options.
The settings for the old colorizer are:</p>
<pre class="literal-block">
comment_font, cweb_section_name_font, directive_font,
doc_part_font, keyword_font, leo_keyword_font, section_name_font,
section_name_brackets_font, string_font, undefined_section_name_font,
latexBackground_font, and latex_background_font.
</pre>
<p>The settings for the new colorizer are all of the above (except keyword_font) plus the following:</p>
<pre class="literal-block">
comment1, comment2_font, comment3_font, comment4_font, function_font,
keyword1_font, keyword2_font, keyword3_font, keyword4_font, label_font,
literal1_font, literal2_font, literal3_font, literal4_font, markup_font,
null_font, and operator_font.
</pre>
<p>To specify a font, say for keyword_font, to be used as the default font for <strong>all</strong> languages,
put the following in the body text of an &#64;font node in leoSettings.leo:</p>
<pre class="literal-block">
# keyword_font_family = None
keyword_font_size = 16
keyword_font_slant = roman
    # roman, italic
keyword_font_weight = bold
    # normal, bold
</pre>
<p>Comments are allowed and undefined settings are set to reasonable defaults.
At present, comments can not follow a setting: comments must start a line.</p>
<p>You can specify per-language settings by preceding the settings names by a prefix x.
Such settings affect only colorizing for language x (i.e., all the modes in modes/x.py when using the new colorizer).
For example, to specify a font for php (only), put the following in the body text of an &#64;font node in leoSettings.leo:</p>
<pre class="literal-block">
# php_keyword_font_family = None
php_keyword_font_size = 16
php_keyword_font_slant = roman
    # roman, italic
php_keyword_font_weight = bold
    # normal, bold
</pre>
<hr class="docutils" />
<p><a class="reference" href="rstplugin3.html"><img alt="back" src="arrow_lt.gif" /></a> <a class="reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference" href="debuggers.html"><img alt="next" src="arrow_rt.gif" /></a></p>
</div>
</div>
</div>
</body>
</html>
