<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title></title>
<style type="text/css">

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



</style>
</head>
<body>
<div class="document">


<!-- rst3: filename: html\scripting.html -->
<p><a class="reference" href="design.html"><img alt="back" src="arrow_lt.gif" /></a> <a class="reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference" href="customizing.html"><img alt="next" src="arrow_rt.gif" /></a></p>
<div class="section">
<h1><a class="toc-backref" href="#id1" id="chapter-7-scripting-leo-with-python" name="chapter-7-scripting-leo-with-python">Chapter 7: Scripting Leo with Python</a></h1>
<p>This chapter describes only the most useful functions, classes and methods in
<tt class="docutils literal"><span class="pre">leo.py</span></tt>. Keep in mind that <em>your scripts have complete access to all of Leo's
source code</em>, that is, all the code in <tt class="docutils literal"><span class="pre">LeoPy.leo</span></tt>. Your scripts can use Leo's
code in whatever ways are convenient. You are <em>not</em> limited by what you see in
this chapter.</p>
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#chapter-7-scripting-leo-with-python" id="id1" name="id1">Chapter 7: Scripting Leo with Python</a><ul>
<li><a class="reference" href="#overview" id="id2" name="id2">Overview</a></li>
<li><a class="reference" href="#g-es-writes-to-the-log-pane" id="id3" name="id3">g.es writes to the log pane</a></li>
<li><a class="reference" href="#app-windowlist-the-list-of-all-open-frames" id="id4" name="id4">app.windowList: the list of all open frames</a></li>
<li><a class="reference" href="#getting-and-setting-headline-and-body-text" id="id5" name="id5">Getting and setting headline and body text</a></li>
<li><a class="reference" href="#traversing-outlines" id="id6" name="id6">Traversing outlines</a><ul>
<li><a class="reference" href="#about-copying-positions" id="id7" name="id7">About copying positions</a></li>
<li><a class="reference" href="#c-allnodes-iter" id="id8" name="id8">c.allNodes_iter</a></li>
<li><a class="reference" href="#p-children-iter" id="id9" name="id9">p.children_iter</a></li>
<li><a class="reference" href="#p-parents-iter-p-self-and-parents-iter" id="id10" name="id10">p.parents_iter &amp; p.self_and_parents_iter</a></li>
<li><a class="reference" href="#p-siblings-iter-p-following-siblings-iter" id="id11" name="id11">p.siblings_iter &amp; p.following_siblings_iter</a></li>
<li><a class="reference" href="#p-subtree-iter-p-self-and-subtree-iter" id="id12" name="id12">p.subtree_iter &amp; p.self_and_subtree_iter</a></li>
<li><a class="reference" href="#testing-whether-a-position-is-valid" id="id13" name="id13">Testing whether a position is valid</a></li>
</ul>
</li>
<li><a class="reference" href="#updating-the-screen" id="id14" name="id14">Updating the screen</a></li>
<li><a class="reference" href="#invoking-commands-from-scripts" id="id15" name="id15">Invoking commands from scripts</a></li>
<li><a class="reference" href="#getting-settings-from-settings-trees" id="id16" name="id16">Getting settings from &#64;settings trees</a></li>
<li><a class="reference" href="#getting-and-setting-preferences" id="id17" name="id17">Getting and setting preferences</a></li>
<li><a class="reference" href="#functions-for-finding-and-changing-text-from-scripts" id="id18" name="id18">Functions for finding and changing text from scripts</a></li>
<li><a class="reference" href="#running-leo-in-batch-mode" id="id19" name="id19">Running Leo in batch mode</a></li>
<li><a class="reference" href="#functions-defined-in-leoglobals-py" id="id20" name="id20">Functions defined in leoGlobals.py</a></li>
<li><a class="reference" href="#redirecting-output-from-scripts" id="id21" name="id21">Redirecting output from scripts</a></li>
<li><a class="reference" href="#writing-to-different-log-tabs" id="id22" name="id22">Writing to different log tabs</a></li>
<li><a class="reference" href="#customizing-panes-with-different-widgets" id="id23" name="id23">Customizing panes with different widgets</a><ul>
<li><a class="reference" href="#official-ivars" id="id24" name="id24">Official ivars</a></li>
<li><a class="reference" href="#common-operations-on-tk-text-widgets" id="id25" name="id25">Common operations on Tk.Text widgets</a></li>
<li><a class="reference" href="#customizing-the-log-pane" id="id26" name="id26">Customizing the log pane</a></li>
<li><a class="reference" href="#customizing-the-body-pane" id="id27" name="id27">Customizing the body pane</a></li>
<li><a class="reference" href="#customizing-the-outine-pane" id="id28" name="id28">Customizing the outine pane</a></li>
</ul>
</li>
<li><a class="reference" href="#summary-of-the-vnode-and-position-classes" id="id29" name="id29">Summary of the vnode and position classes</a><ul>
<li><a class="reference" href="#iterators" id="id30" name="id30">Iterators</a></li>
<li><a class="reference" href="#getters" id="id31" name="id31">Getters</a></li>
<li><a class="reference" href="#setters" id="id32" name="id32">Setters</a></li>
</ul>
</li>
<li><a class="reference" href="#creating-script-buttons" id="id33" name="id33">Creating script buttons</a></li>
<li><a class="reference" href="#test-and-suite-nodes" id="id34" name="id34">&#64;test and &#64;suite nodes</a></li>
</ul>
</li>
</ul>
</div>
<!-- Links used in this document. -->
<!-- WARNING: image targets may not have upper case letters! -->
<div class="section">
<h2><a class="toc-backref" href="#id2" id="overview" name="overview">Overview</a></h2>
<p>Leo's source code is a collection of classes, along with utility functions in
<tt class="docutils literal"><span class="pre">leoGlobals.py</span></tt>. Here are Leo's most important classes and objects:</p>
<dl class="docutils">
<dt><strong>The Execute Script command predefines c, g and p</strong></dt>
<dd><p class="first">Leo's <tt class="docutils literal"><span class="pre">Execute</span> <span class="pre">Script</span></tt> command predefines <tt class="docutils literal"><span class="pre">c</span></tt> to be the commander of the
outline containing the script. <tt class="docutils literal"><span class="pre">g</span></tt> and <tt class="docutils literal"><span class="pre">p</span></tt> are predefined as follows:</p>
<pre class="last literal-block">
import leoGlobals as g
p = c.currentPosition()
</pre>
</dd>
<dt><strong>g.app</strong></dt>
<dd>The <strong>application object</strong> representing the entire Leo application.
The ivars (instance variables) of <tt class="docutils literal"><span class="pre">g.app</span></tt> represent Leo's global variables.</dd>
<dt><strong>commander</strong></dt>
<dd>An instance of the <tt class="docutils literal"><span class="pre">Commands</span></tt> class in <tt class="docutils literal"><span class="pre">leoCommands.py</span></tt>.
Commanders represent commands for a <em>particular</em> window.
Each open Leo window has its own commander.
By convention, any variable named <tt class="docutils literal"><span class="pre">c</span></tt> is a commander.</dd>
<dt><strong>frame</strong></dt>
<dd>An instance of the base <tt class="docutils literal"><span class="pre">leoFrame</span></tt> class in <tt class="docutils literal"><span class="pre">leoFrame.py</span></tt>.
Frames contains all the internal data needed to manage a Leo window.
Given a commander <tt class="docutils literal"><span class="pre">c</span></tt>, <tt class="docutils literal"><span class="pre">c.frame</span></tt> is commanders frame.
Given a frame <tt class="docutils literal"><span class="pre">f</span></tt>, <tt class="docutils literal"><span class="pre">f.c</span></tt> is the frame's commander.</dd>
<dt><strong>position</strong></dt>
<dd><p class="first">An instance of the <tt class="docutils literal"><span class="pre">position</span></tt> class in <tt class="docutils literal"><span class="pre">leoNodes.py</span></tt>.
A position object represents the location of a particular node <em>in a tree traversal</em>.
By convention, variables named <tt class="docutils literal"><span class="pre">p</span></tt>, <tt class="docutils literal"><span class="pre">p1</span></tt> or <tt class="docutils literal"><span class="pre">p2</span></tt> are positions.
For any <tt class="docutils literal"><span class="pre">position</span></tt> <tt class="docutils literal"><span class="pre">p</span></tt>, <tt class="docutils literal"><span class="pre">p.v</span></tt> is the vnode at that position and <tt class="docutils literal"><span class="pre">p.v.t</span></tt> is the tnode at that position.
<strong>Positions are the primary way to access data.</strong>
<tt class="docutils literal"><span class="pre">c.currentPosition</span></tt> and <tt class="docutils literal"><span class="pre">c.rootPosition</span></tt> return positions.
From those starting point, it is possible to access the data in any node.</p>
<p><strong>Important</strong>:
Positions can become <em>invalid</em> when the structure of the outline changes.
Therefore, plugins and scripts must <em>not</em> store positions for use at a later time if the outline
could have changed in the meantime.</p>
<p class="last"><strong>Important</strong>:
For compatibility with old (pre-4.2) scripts, <tt class="docutils literal"><span class="pre">c.currentVnode</span></tt> and
<tt class="docutils literal"><span class="pre">c.rootVnode</span></tt> methods return <em>positions</em> not vnodes. Old scripts appear to
be using vnodes; in fact they are using positions. I call such scripts
<strong>confused</strong> scripts. Confused scripts work because the <tt class="docutils literal"><span class="pre">position</span></tt> class
is designed to make them work. We'll see how this works in detail in <a class="reference" href="#about-copying-positions">About
copying positions</a>.  This section is <strong>supremely important</strong>.</p>
</dd>
<dt><strong>vnode</strong></dt>
<dd>An instance of the <tt class="docutils literal"><span class="pre">vnode</span></tt> class in <tt class="docutils literal"><span class="pre">leoNodes.py</span></tt>.
vnodes represent an outline node.
Normally, scripts access vnodes via the <tt class="docutils literal"><span class="pre">position</span></tt> class described below.
By convention, variables named <tt class="docutils literal"><span class="pre">v</span></tt>, <tt class="docutils literal"><span class="pre">v1</span></tt> or <tt class="docutils literal"><span class="pre">v2</span></tt> refer to vnodes.
<strong>Important</strong>: scripts normally should use positions, not vnodes.</dd>
<dt><strong>tnode</strong></dt>
<dd>An instance of the <tt class="docutils literal"><span class="pre">tnode</span></tt> class in <tt class="docutils literal"><span class="pre">leoNodes.py</span></tt>.
tnodes represent the actual data in a vnode, including headline and body text.
Cloned <em>vnodes</em> share the tnode <em>of their first child</em>.
For any vnode <tt class="docutils literal"><span class="pre">v</span></tt>, <tt class="docutils literal"><span class="pre">v.t</span></tt> is v's tnode.
<strong>Important</strong>: If <tt class="docutils literal"><span class="pre">p</span></tt> is a <tt class="docutils literal"><span class="pre">position</span></tt>, <tt class="docutils literal"><span class="pre">p.v.t</span></tt> is the tnode associated with that position.
Many positions may share the same tnode.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id3" id="g-es-writes-to-the-log-pane" name="g-es-writes-to-the-log-pane">g.es writes to the log pane</a></h2>
<p>The g.es method prints its arguments to the Log tab of the log pane:</p>
<pre class="literal-block">
g.es(&quot;Hello world&quot;)
</pre>
<p>g.es converts non-string arguments using repr:</p>
<pre class="literal-block">
g.es(c)
</pre>
<p>g.es prints multiple arguments separated by commas:</p>
<pre class="literal-block">
g.es(&quot;Hello&quot;,&quot;world&quot;)
</pre>
<p>To create a tab named 'Test' or make it visible if it already exists:</p>
<pre class="literal-block">
c.frame.log.selectTab('Test')
</pre>
<p>When first created, a tab contains a Tk.Text widget.
To write to this widget, add the tabName argument to g.es:</p>
<pre class="literal-block">
g.es('Test',color='blue',tabName='Test')
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id4" id="app-windowlist-the-list-of-all-open-frames" name="app-windowlist-the-list-of-all-open-frames">app.windowList: the list of all open frames</a></h2>
<p>The windowlist attribute of the application instance contains the list of the
frames of all open windows. The commands ivar of the frame gives the commander
for that frame:</p>
<pre class="literal-block">
windows = g.app.windowList # get the list of all open frames.
g.es(&quot;windows...&quot;)
for f in windows:
    c = f.c # c is f's commander
    g.es(f)
    g.es(f.shortFileName())
    g.es(c)
    g.es(c.rootPosition())
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id5" id="getting-and-setting-headline-and-body-text" name="getting-and-setting-headline-and-body-text">Getting and setting headline and body text</a></h2>
<p>Here is how to access the data of a Leo window:</p>
<pre class="literal-block">
g.es(p) # p is already defined.
p = c.currentPosition() # get the current position.
g.es(p)
g.es(&quot;head:&quot;,p.headString())
g.es(&quot;body:&quot;,p.bodyString())
</pre>
<p>Here is how to access data at position <tt class="docutils literal"><span class="pre">p</span></tt>.
<strong>Note</strong>: these methods work whether or not <tt class="docutils literal"><span class="pre">p</span></tt> is the current position:</p>
<pre class="literal-block">
body = p.bodyString()
head = p.headString()
c.setBodyString(p,body) # set body text of p to body.
c.setHeadString(p,head) # set headline text of p to head.
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id6" id="traversing-outlines" name="traversing-outlines">Traversing outlines</a></h2>
<p>The proper way to traverse an outline is with an iterator.
Iterators are defined only by the position class;
vnodes can not have iterators because vnodes may appear in multiple places in an outline.</p>
<div class="section">
<h3><a class="toc-backref" href="#id7" id="about-copying-positions" name="about-copying-positions">About copying positions</a></h3>
<p>Understanding this section is <strong>supremely important</strong> for anyone who wants to
script Leo properly.</p>
<p>By default, all iterators discussed below use a <strong>single</strong> position to move
through the outline. This is a vital optimization; otherwise Leo would generate
one or more position object for each node of a tree traversal. However, it means
that it is <strong>useless</strong> to try to capture a position with:</p>
<pre class="literal-block">
p2 = p  # Wrong.  p2 will change after this assignment.
</pre>
<p>Instead, scripts and plugins should use <tt class="docutils literal"><span class="pre">p.copy()</span></tt> to 'capture' the value of a position:</p>
<pre class="literal-block">
p2 = p.copy()   # Correct: p2 will not change when p changes later.
</pre>
<p>Another way to solve this problem is to set <tt class="docutils literal"><span class="pre">copy=True</span></tt> when using an iterator:</p>
<pre class="literal-block">
d = {}
for p in c.allNodes_iter(copy=True):
    d[p.v.t] = p
</pre>
<p>This creates a dictionary of (unchanging!) positions, indexed via tnode.
<strong>Warning</strong> The positions in this dictionary will become invalid when the
outline's structure changes. It would be wrong to save a dictionary like this
for use between commands.</p>
<p>Setting the <tt class="docutils literal"><span class="pre">copy=True</span></tt> argument to iterators is an acceptable strategy for
infrequently used scripts; it is not acceptable for heavily used code in Leo's
core: it would create huge numbers of positions that would immediately be
candidates for garbage collection.</p>
<p><strong>Important</strong>: 'Confused' scripts work because the <tt class="docutils literal"><span class="pre">position</span></tt> methods that
simulate the old <tt class="docutils literal"><span class="pre">vnode</span></tt> methods automatically create copies of positions when
'moving' through an outline. Thus, confused scripts generate many more positions
than would the equivalent script that uses <tt class="docutils literal"><span class="pre">position</span></tt> iterators. Such is the
price of compatibility.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id8" id="c-allnodes-iter" name="c-allnodes-iter">c.allNodes_iter</a></h3>
<p>The <tt class="docutils literal"><span class="pre">c.allNodes_iter</span></tt> iterator returns a list of all positions in the outline.
This script makes a list of all the nodes in an outline:</p>
<pre class="literal-block">
nodes = [p for p in c.allNodes_iter()]
g.es(&quot;This outline contains %d nodes&quot; % len(nodes))
</pre>
<p>Here is one way to count the nodes of an outline:</p>
<pre class="literal-block">
count = 0
for p in c.allNodes_iter():
    count += 1
g.es(&quot;This outline contains %d nodes&quot; % count)
</pre>
<p>Here is a way to count the <em>distinct</em> vnodes of an outline:</p>
<pre class="literal-block">
positions = 0 ; tnodes = {}
for p in c.allNodes_iter():
    positions += 1
    if not tnodes.get(p.v.t):
        tnodes[p.v.t] = p.v.t
g.es(&quot;%8s positions&quot; % positions)
g.es(&quot;%8s vnodes&quot; % len(tnodes.keys()))
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id9" id="p-children-iter" name="p-children-iter">p.children_iter</a></h3>
<p>The <tt class="docutils literal"><span class="pre">p.children_iter</span></tt> iterator returns a list of all children of position <tt class="docutils literal"><span class="pre">p</span></tt>:</p>
<pre class="literal-block">
parent = p.parent()
g.es(&quot;children of %s&quot; % parent.headString(),color=&quot;purple&quot;)
for p in parent.children_iter():
    g.es(p.headString())
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id10" id="p-parents-iter-p-self-and-parents-iter" name="p-parents-iter-p-self-and-parents-iter">p.parents_iter &amp; p.self_and_parents_iter</a></h3>
<p>The <tt class="docutils literal"><span class="pre">p.parents_iter</span></tt> iterator returns a list of all parents of position <tt class="docutils literal"><span class="pre">p</span></tt>, excluding <tt class="docutils literal"><span class="pre">p</span></tt>:</p>
<pre class="literal-block">
current = p.copy()
g.es(&quot;inclusive parents of %s&quot; % current.headString(),color=&quot;purple&quot;)
for p in current.self_and_parents_iter():
    g.es(p.headString())
</pre>
<p>The <tt class="docutils literal"><span class="pre">p.self_and_parents_iter</span></tt> iterator returns a list of all parents of position <tt class="docutils literal"><span class="pre">p</span></tt>, including <tt class="docutils literal"><span class="pre">p</span></tt>:</p>
<pre class="literal-block">
current = p.copy()
g.es(&quot;exclusive of %s&quot; % current.headString(),color=&quot;purple&quot;)
for p in current.parents_iter():
    g.es(p.headString())
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id11" id="p-siblings-iter-p-following-siblings-iter" name="p-siblings-iter-p-following-siblings-iter">p.siblings_iter &amp; p.following_siblings_iter</a></h3>
<p>The <tt class="docutils literal"><span class="pre">p.siblings_iter</span></tt> iterator returns a list of all siblings of position <tt class="docutils literal"><span class="pre">p</span></tt>:</p>
<pre class="literal-block">
current = c.currentPosition()
g.es(&quot;all siblings of %s&quot; % current.headString(),color=&quot;purple&quot;)
for p in current.self_and_siblings_iter():
    g.es(p.headString())
</pre>
<p>The <tt class="docutils literal"><span class="pre">p.following_siblings_iter</span></tt> iterator returns a list of all siblings that follow position <tt class="docutils literal"><span class="pre">p</span></tt>:</p>
<pre class="literal-block">
current = c.currentPosition()
g.es(&quot;following siblings of %s&quot; % current.headString(),color=&quot;purple&quot;)
for p in current.following_siblings_iter():
    g.es(p.headString())
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id12" id="p-subtree-iter-p-self-and-subtree-iter" name="p-subtree-iter-p-self-and-subtree-iter">p.subtree_iter &amp; p.self_and_subtree_iter</a></h3>
<p>The p.subtree_iter iterator returns a list of all positions in <tt class="docutils literal"><span class="pre">p</span></tt>'s subtree, excluding <tt class="docutils literal"><span class="pre">p</span></tt>:</p>
<pre class="literal-block">
parent = p.parent()
g.es(&quot;exclusive subtree of %s&quot; % parent.headString(),color=&quot;purple&quot;)
for p in parent.subtree_iter():
    g.es(p.headString())
</pre>
<p>The p.self_and_subtree_iter iterator returns a list of all positions in <tt class="docutils literal"><span class="pre">p</span></tt>'s subtree, including <tt class="docutils literal"><span class="pre">p</span></tt>:</p>
<pre class="literal-block">
parent = p.parent()
g.es(&quot;inclusive subtree of %s&quot; % parent.headString(),color=&quot;purple&quot;)
for p in parent.self_and_subtree_iter():
    g.es(p.headString())
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id13" id="testing-whether-a-position-is-valid" name="testing-whether-a-position-is-valid">Testing whether a position is valid</a></h3>
<p>The tests:</p>
<pre class="literal-block">
if p:       # Right
if not p:   # Right
</pre>
<p>are the <strong>only</strong> correct ways to test whether a position <tt class="docutils literal"><span class="pre">p</span></tt> is valid.
In particular, the following <strong>will not work</strong>:</p>
<pre class="literal-block">
if p is None:       # Wrong
if p is not None:   # Wrong
</pre>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id14" id="updating-the-screen" name="updating-the-screen">Updating the screen</a></h2>
<p>You can use <tt class="docutils literal"><span class="pre">c.redraw_now</span></tt> to redraw the entire screen immediately:</p>
<pre class="literal-block">
c.redraw_now()
</pre>
<p>However, Leo's code redraws the screen using the following pattern:</p>
<pre class="literal-block">
c.beginUpdate()
try:
    &lt;&lt; whatever &gt;&gt;
finally:
    c.endUpdate()
</pre>
<p>This suppresses redraws inside &lt;&lt;whatever&gt;&gt; that would otherwise be caused by
<tt class="docutils literal"><span class="pre">c.endUpdate</span></tt>. <tt class="docutils literal"><span class="pre">c.endUpdate</span></tt> takes an optional argument:</p>
<pre class="literal-block">
c.endUpdate(flag)
</pre>
<p>redraws the screen only if flag is True. This is an important pattern. Leo uses
<tt class="docutils literal"><span class="pre">c.beginUpdate</span></tt> and <tt class="docutils literal"><span class="pre">c.endUpdate</span></tt> almost everywhere to redraw the screen, so
provided that &lt;&lt; whatever &gt;&gt; contains no calls to <tt class="docutils literal"><span class="pre">c.redraw_now</span></tt> this pattern
insures that at most one redraw occurs.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id15" id="invoking-commands-from-scripts" name="invoking-commands-from-scripts">Invoking commands from scripts</a></h2>
<p>Leo dispatches commands using c.doCommand,
which calls the &quot;command1&quot; and &quot;command2&quot; hook routines for the given label.
c.doCommand catches all exceptions thrown by the command:</p>
<pre class="literal-block">
c.doCommand(c.markHeadline,label=&quot;markheadline&quot;)
</pre>
<p>You can also call command handlers directly so that hooks will not be called:</p>
<pre class="literal-block">
c.markHeadline()
</pre>
<p>You can invoke minibuffer commands by name.  For example:</p>
<pre class="literal-block">
c.executeMinibufferCommand('open-outline')
</pre>
<p>c.keyHandler.funcReturn contains the value returned from the command.
In many cases, as above, this value is simply 'break'.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id16" id="getting-settings-from-settings-trees" name="getting-settings-from-settings-trees">Getting settings from &#64;settings trees</a></h2>
<p>Any .leo file may contain an <tt class="docutils literal"><span class="pre">&#64;settings</span></tt> tree, so settings may be different for each commander.
Plugins and other scripts can get the value of settings as follows:</p>
<pre class="literal-block">
format_headlines = c.config.getBool('rst3_format_headlines')
g.es('format_headlines',format_headlines)
</pre>
<p>The <tt class="docutils literal"><span class="pre">c.config</span></tt> class has the following getters.
See the <tt class="docutils literal"><span class="pre">configSettings</span></tt> in <tt class="docutils literal"><span class="pre">leoCommands.py</span></tt> for details:</p>
<pre class="literal-block">
getBool
getColor
getDirectory
getFloat
getInt
getLanguage
getRatio
getShortcut
getString
</pre>
<p>You can set any <em>existing</em> item in an <tt class="docutils literal"><span class="pre">&#64;settings</span></tt> tree with <tt class="docutils literal"><span class="pre">c.config.set(p,setting,val)</span></tt>.
For example:</p>
<pre class="literal-block">
for val in (False,True):
    c.config.set(p,'rst3_format_headlines',val)
    format_headlines = c.config.getBool('rst3_format_headlines')
    g.es('format_headlines',format_headlines)
</pre>
<p><tt class="docutils literal"><span class="pre">c.config.set</span></tt> does not change the <tt class="docutils literal"><span class="pre">&#64;settings</span></tt> tree; it simply changes the values returned by the getters.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id17" id="getting-and-setting-preferences" name="getting-and-setting-preferences">Getting and setting preferences</a></h2>
<p>Each commander maintains its own preferences.
Your scripts can get the following ivars:</p>
<pre class="literal-block">
ivars = (
    'output_doc_flag',
    'page_width',
    'page_width',
    'tab_width',
    'tangle_batch_flag',
    'tangle_directory',
    'target_language',
    'untangle_batch_flag',
    'use_header_flag',
)

g.es(&quot;Prefs ivars...\n&quot;,color=&quot;purple&quot;)
for ivar in ivars:
    g.es(getattr(c,ivar))
</pre>
<p>If your script sets <tt class="docutils literal"><span class="pre">c.tab_width</span></tt> your script may call <tt class="docutils literal"><span class="pre">f.setTabWidth</span></tt> to redraw the screen:</p>
<pre class="literal-block">
c.tab_width = -4    # Change this and see what happens.
c.frame.setTabWidth(c.tab_width)
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id18" id="functions-for-finding-and-changing-text-from-scripts" name="functions-for-finding-and-changing-text-from-scripts">Functions for finding and changing text from scripts</a></h2>
<p>The file <tt class="docutils literal"><span class="pre">leoFindScript.py</span></tt> contains functions for finding and changing text
from within scripts.  See <tt class="docutils literal"><span class="pre">leoFindScript.py</span></tt> in <tt class="docutils literal"><span class="pre">LeoPy.leo</span></tt> for full details.</p>
<p>The findall function returns a list of tuples <tt class="docutils literal"><span class="pre">(v,pos)</span></tt> describing matches in
<tt class="docutils literal"><span class="pre">c</span></tt>'s entire tree:</p>
<pre class="literal-block">
import leoFindScript

pattern=&quot;import leoGlobals as g&quot;
result = leoFindScript.findAll(c,pattern,bodyFlag=1)

g.es(&quot;%-3d instances of: '%s'...\n&quot; % (len(result),pattern),color=&quot;purple&quot;)

for v,pos in result:
    body = v.bodyString()
    g.es('\n%-4d %s' % (pos,v.headString()))
    g.es(g.get_line_after(body,pos))
</pre>
<p>The <tt class="docutils literal"><span class="pre">reFindall</span></tt> function returns a list of tuples <tt class="docutils literal"><span class="pre">(v,mo,pos)</span></tt>, where <tt class="docutils literal"><span class="pre">mo</span></tt>
is a <tt class="docutils literal"><span class="pre">MatchObject</span></tt>. The <tt class="docutils literal"><span class="pre">reFlags</span></tt> argument are flags to <tt class="docutils literal"><span class="pre">re.search</span></tt>:</p>
<pre class="literal-block">
import leoFindScript

pattern=&quot;from .* import&quot;
result = leoFindScript.reFindAll(c,pattern,bodyFlag=1,reFlags=None)

g.es(&quot;%-3d instances of: '%s'...\n&quot; % (len(result),pattern),color=&quot;purple&quot;)
for v,mo,pos in result:
    body = v.bodyString()
    g.es('\n%-4d %s' % (pos,v.headString()))
    g.es(g.get_line_after(body,pos))
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id19" id="running-leo-in-batch-mode" name="running-leo-in-batch-mode">Running Leo in batch mode</a></h2>
<p>On startup, Leo looks for two arguments of the form:</p>
<pre class="literal-block">
--script scriptFile
</pre>
<p>If found, Leo enters batch mode. In batch mode Leo does not show any windows.
Leo assumes the scriptFile contains a Python script and executes the contents of
that file using Leo's <tt class="docutils literal"><span class="pre">Execute</span> <span class="pre">Script</span></tt> command. By default, Leo sends all
output to the console window. Scripts in the scriptFile may disable or enable
this output by calling <tt class="docutils literal"><span class="pre">app.log.disable</span></tt> or <tt class="docutils literal"><span class="pre">app.log.enable</span></tt></p>
<p>Scripts in the scriptFile may execute any of Leo's commands except the <tt class="docutils literal"><span class="pre">Edit</span> <span class="pre">Body</span></tt>
and <tt class="docutils literal"><span class="pre">Edit</span> <span class="pre">Headline</span></tt> commands. Those commands require interaction with the user.
For example, the following batch script reads a Leo file and prints all the
headlines in that file:</p>
<pre class="literal-block">
path = r&quot;c:\prog\leoCVS\leo\test\test.leo&quot;

g.app.log.disable() # disable reading messages while opening the file
flag,newFrame = g.openWithFileName(path,None)
g.app.log.enable() # re-enable the log.

for p in newFrame.c.allNodes_iter():
    g.es(g.toEncodedString(p.headString(),&quot;utf-8&quot;))
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id20" id="functions-defined-in-leoglobals-py" name="functions-defined-in-leoglobals-py">Functions defined in leoGlobals.py</a></h2>
<p><tt class="docutils literal"><span class="pre">leoGlobals.py</span></tt> contains many utility functions and constants.
The following script prints all the names defined in <tt class="docutils literal"><span class="pre">leoGlobals.py</span></tt>:</p>
<pre class="literal-block">
g.es(&quot;Names defined in leoGlobals.py&quot;,color=&quot;purple&quot;)
names = g.__dict__.keys()
names.sort()
for name in names:
    g.es(name)
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id21" id="redirecting-output-from-scripts" name="redirecting-output-from-scripts">Redirecting output from scripts</a></h2>
<p><tt class="docutils literal"><span class="pre">leoGlobals.py</span></tt> defines 6 convenience methods for redirecting stdout and stderr:</p>
<pre class="literal-block">
g.redirectStderr() # Redirect stderr to the current log pane.
g.redirectStdout() # Redirect stdout to the current log pane.
g.restoreStderr()  # Restores stderr so it prints to the console window.
g.restoreStdout()  # Restores stdout so it prints to the console window.
g.stdErrIsRedirected() # Returns True if the stderr stream is redirected to the log pane.
g.stdOutIsRedirected() # Returns True if the stdout stream is redirected to the log pane.
</pre>
<p>Calls need <em>not</em> be paired. Redundant calls are ignored and the last call made
controls where output for each stream goes.
<strong>Note</strong>: you must execute Leo in a console window to see non-redirected output from the print statement:</p>
<pre class="literal-block">
print &quot;stdout isRedirected:&quot;, g.stdOutIsRedirected()
print &quot;stderr isRedirected:&quot;, g.stdErrIsRedirected()

g.redirectStderr()
print &quot;stdout isRedirected:&quot;, g.stdOutIsRedirected()
print &quot;stderr isRedirected:&quot;, g.stdErrIsRedirected()

g.redirectStdout()
print &quot;stdout isRedirected:&quot;, g.stdOutIsRedirected()
print &quot;stderr isRedirected:&quot;, g.stdErrIsRedirected()

g.restoreStderr()
print &quot;stdout isRedirected:&quot;, g.stdOutIsRedirected()
print &quot;stderr isRedirected:&quot;, g.stdErrIsRedirected()

g.restoreStdout()
print &quot;stdout isRedirected:&quot;, g.stdOutIsRedirected()
print &quot;stderr isRedirected:&quot;, g.stdErrIsRedirected()
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id22" id="writing-to-different-log-tabs" name="writing-to-different-log-tabs">Writing to different log tabs</a></h2>
<p>Plugins and scripts can create new tabs in the log panel.
The following creates a tab named test or make it visible if it already exists:</p>
<pre class="literal-block">
c.frame.log.selectTab('Test')
</pre>
<p>g.es, g.enl, g.ecnl, g.ecnls write to the log tab specified by the optional
tabName argument. The default for tabName is 'Log'. The put and putnl methods of
the tkinterLog class also take an optional tabName argument which defaults to
'Log'.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id23" id="customizing-panes-with-different-widgets" name="customizing-panes-with-different-widgets">Customizing panes with different widgets</a></h2>
<p>Tk/Tkinter make it easy to customize the contents of any of Leo's panes. The
following sections will discuss the 'official' ivars that make it possible for
scripts to access and alter the contents of panes. The next three sections will
give examples of modifying each pane.</p>
<div class="section">
<h3><a class="toc-backref" href="#id24" id="official-ivars" name="official-ivars">Official ivars</a></h3>
<p>The c.frame.log class contains the following 'official' ivars:</p>
<pre class="literal-block">
g.es('tabName',c.frame.log.tabName)     # The name of the active tab.
g.es('tabFrame',c.frame.log.tabFrame)   # The Tk.Frame containing all the other widgets of the tab.
g.es('logCtrl',c.frame.log.logCtrl)     # Tk.Text widget containing the log text.
</pre>
<p>The following ivars provide access to the body pane:</p>
<pre class="literal-block">
g.es('bodyFrame',c.frame.body.frame)    # The Tk.Frame widget containing the c.frame.body.bodyCtrl
</pre>
<p>The following ivars provide access to the outline pane:</p>
<pre class="literal-block">
g.es('canvas',c.frame.tree.canvas) # The Tk.Canvas on which Leo's outline is drawn.
</pre>
<p>Tkinter provides a way of determining the enclosing widget of any widget.
The body text is enclosed in a Pmw.PanedWidget to support multiple editors.</p>
<blockquote>
w = c.frame.body.bodyCtrl
parent = w.pack_info().get('in')
g.es('bodyCtrl.parent',parent) # The Tk.Frame containing the body text.</blockquote>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id25" id="common-operations-on-tk-text-widgets" name="common-operations-on-tk-text-widgets">Common operations on Tk.Text widgets</a></h3>
<p>The following is no substitute for a full discussion of programming the Tk.Text
widget: it can do lots.</p>
<p>To clear the log:</p>
<pre class="literal-block">
w = c.frame.log.logCtrl
w.delete('1.0','end')
</pre>
<p>To write a line to the end of the log:</p>
<pre class="literal-block">
w = c.frame.log.logCtrl
w.insert('end','This is a test\n')
</pre>
<p>To get the entire contents of the log:</p>
<pre class="literal-block">
w = c.frame.log.logCtrl
g.es(w.get('1.0','end')+'\n')
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id26" id="customizing-the-log-pane" name="customizing-the-log-pane">Customizing the log pane</a></h3>
<p>The following line removes the initial text widget:</p>
<pre class="literal-block">
c.frame.log.logCtrl.pack_forget()
</pre>
<p>To make the text widget visible again:</p>
<pre class="literal-block">
c.frame.log.logCtrl.pack(side='top',expand=1,fill='both')
</pre>
<p>Plugins and scripts can pack any other widgets into c.frame.log.tabFrame.
For example, the following replaces the default text widget with a red box:</p>
<pre class="literal-block">
import Tkinter as Tk

# Remove the old contents.
w = c.frame.log.logCtrl
parent =  w.pack_info().get('in')
w.pack_forget()

# Replace with a red frame.
f = c.frame.newLog = Tk.Frame(parent,background='red')
f.pack(side='left',expand=1,fill='both')
</pre>
<p>And the following will restore the original pane:</p>
<pre class="literal-block">
c.frame.newLog.pack_forget()
w = c.frame.log.logCtrl
w.pack(side='left',expand=1,fill='both')
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id27" id="customizing-the-body-pane" name="customizing-the-body-pane">Customizing the body pane</a></h3>
<p>Warning: you will find it hard to execute scripts after removing the body pane,
so you had best make the following two scripts into script buttons before
executing them :-)</p>
<p>Plugins and scripts can pack any other widgets into c.frame.log.tabFrame.
For example, the following replaces the default text widget with a red box:</p>
<pre class="literal-block">
import Tkinter as Tk

w = c.frame.body.bodyCtrl
parent =  w.pack_info().get('in')
w.pack_forget()

f = c.frame.newBody = Tk.Frame(parent,background='red')
f.pack(side='left',expand=1,fill='both')
</pre>
<p>To restore:</p>
<pre class="literal-block">
c.frame.newBody.pack_forget()
w = c.frame.body.bodyCtrl
w.pack(side='left',expand=1,fill='both')
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id28" id="customizing-the-outine-pane" name="customizing-the-outine-pane">Customizing the outine pane</a></h3>
<p>The following replaces the outline pane with a red frame:</p>
<pre class="literal-block">
import Tkinter as Tk

w = c.frame.tree.canvas
parent =  w.pack_info().get('in')
w.pack_forget()

f = c.frame.newTree = Tk.Frame(parent,background='red')
f.pack(side='left',expand=1,fill='both')
</pre>
<p>And this script restores the outline:</p>
<pre class="literal-block">
c.frame.newTree.pack_forget()
c.frame.tree.canvas.pack(side='left',expand=1,fill='both')
</pre>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id29" id="summary-of-the-vnode-and-position-classes" name="summary-of-the-vnode-and-position-classes">Summary of the vnode and position classes</a></h2>
<p>Most scripts will use methods of the position class to access information in an
outline. The following sections summarizes the most useful methods that your
scripts can use. For a complete list, see the <tt class="docutils literal"><span class="pre">leoNodes.py</span></tt> in of <tt class="docutils literal"><span class="pre">LeoPy.leo</span></tt>.</p>
<div class="section">
<h3><a class="toc-backref" href="#id30" id="iterators" name="iterators">Iterators</a></h3>
<p>Iterators exist only in the position class:</p>
<pre class="literal-block">
c.allNodes_iter            # returns all positions in c's outline.
p.children_iter            # returns all children of p.
p.parents_iter             # returns all parents of p.
p.self_and_parents_iter    # returns p and all parents of p.
p.siblings_iter            # returns all siblings of p, including p.
p.following_siblings_iter  # returns all siblings following p.
p.subtree_iter             # returns all positions in p's subtree, excluding p.
p.self_and_subtree_iter    # returns all positions in p's subtree, including p.
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id31" id="getters" name="getters">Getters</a></h3>
<p>Here are the most useful getters of the <tt class="docutils literal"><span class="pre">vnode</span></tt> and <tt class="docutils literal"><span class="pre">position</span></tt> classes.</p>
<p>Returning strings:</p>
<pre class="literal-block">
p.bodyString() # the body string of p.
p.headString() # the headline string of p.
</pre>
<p>Returning ints:</p>
<pre class="literal-block">
p.childIndex()
p.numberOfChildren()
p.level()
</pre>
<p>Returning bools representing property bits:</p>
<pre class="literal-block">
p.hasChildren()
p.isAncestorOf(v2) # True if v2 is a child, grandchild, etc. of p.
p.isCloned()
p.isDirty()
p.isExpanded()
p.isMarked()
p.isVisible()
p.isVisited()
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id32" id="setters" name="setters">Setters</a></h3>
<p>Here are the most useful setters of the <tt class="docutils literal"><span class="pre">Commands</span></tt> and <tt class="docutils literal"><span class="pre">position</span></tt> classes.
The following setters of the <tt class="docutils literal"><span class="pre">position</span></tt> class regardless of whether
<tt class="docutils literal"><span class="pre">p</span></tt> is the presently selected position:</p>
<pre class="literal-block">
c.setBodyString(p,s)  # Sets the body text of p.
c.setHeadString(p,s)  # Sets the headline text of p.
</pre>
<p>Moving nodes:</p>
<pre class="literal-block">
p.moveAfter(v2)           # move p after v2
p.moveToNthChildOf(v2,n)  # move p to the n'th child of v2
p.moveToRoot(oldRoot)     # make p the root position.
                          # oldRoot must be the old root position if it exists.
</pre>
<p>The &quot;visited&quot; bit may be used by commands or scripts for any purpose.
Many commands use this bits for tree traversal, so these bits do not persist:</p>
<pre class="literal-block">
c.clearAllVisited() # Clears all visited bits in c's tree.
p.clearVisited()
p.setVisited()
</pre>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id33" id="creating-script-buttons" name="creating-script-buttons">Creating script buttons</a></h2>
<p>Creating a script button should be your first thought whenever you want to
automate any task. The scripting plugin, <tt class="docutils literal"><span class="pre">mod_scripting.py</span></tt>, puts two buttons
in the icon menu, a pink <tt class="docutils literal"><span class="pre">Run</span> <span class="pre">Script</span></tt> button and a yellow <tt class="docutils literal"><span class="pre">Script</span> <span class="pre">Button</span></tt>
button. The <tt class="docutils literal"><span class="pre">Run</span> <span class="pre">Script</span></tt> button does the same thing as the <tt class="docutils literal"><span class="pre">Execute</span> <span class="pre">Script</span></tt>
command. The <tt class="docutils literal"><span class="pre">Script</span> <span class="pre">Button</span></tt> button is the interesting one. It creates a
button, confusingly called a <strong>script button</strong> in the icon area. A script button
executes a script when you push it.</p>
<p>Suppose node N is selected. When you press the <tt class="docutils literal"><span class="pre">Script</span> <span class="pre">Button</span></tt> button a new
(pink) script button is created. The name of the new button is N's headline
text. The script associated with the new button is N's body text. Now whenever
you press the new button, N's script is executed on the <strong>presently</strong> selected
node. Script buttons are extraordinarily useful. In effect, each script button
defines an instant command! For example, sometimes my fingers get tired of
saving a file. I simply put <tt class="docutils literal"><span class="pre">Save</span></tt> in a node's headline and <tt class="docutils literal"><span class="pre">c.save()</span></tt> in
the body text. I hit the <tt class="docutils literal"><span class="pre">Script</span> <span class="pre">Button</span></tt> button and I get a new button called
<tt class="docutils literal"><span class="pre">Save</span></tt> that will save the outline when I press it.</p>
<p>Here's a more interesting example. The following script searches the present node
and its ancestors looking for an <tt class="docutils literal"><span class="pre">&#64;rst</span></tt> node. When such a node is found the
script calls the <a class="reference" href="rstplugin3.html">rst3 plugin</a> to format it. I don't have to select the actual
<tt class="docutils literal"><span class="pre">&#64;rst</span></tt> node; I can select any of its children:</p>
<pre class="literal-block">
import leoPlugins
rst3 = leoPlugins.getPluginModule('rst3')
if rst3: # already loaded.
    controller = rst3.controllers.get(c)
    if controller:
        for p in p.self_and_parents_iter():
            if p.headString().startswith('&#64;rst '):
                controller.processTree(p)
                break
else: # Just load the plugin.
    rst3 = leoPlugins.loadOnePlugin('rst3',verbose=True)
    if rst3:
        g.es('rst3 loaded')
        rst3.onCreate('tag',{'c':c})
    else:
        # Ask to be removed.
        g.app.scriptDict['removeMe'] = True
</pre>
<p><strong>Notes</strong>:</p>
<ul class="simple">
<li>The scripting plugin pre-defines the <tt class="docutils literal"><span class="pre">c</span></tt>, <tt class="docutils literal"><span class="pre">g</span></tt> and <tt class="docutils literal"><span class="pre">p</span></tt> symbols
just as the <tt class="docutils literal"><span class="pre">Execute</span> <span class="pre">Script</span></tt> command does.</li>
<li>By default a script button executes the <strong>present</strong> body text of the node that original created the script button.
This is very handy: you can modify a script button's script at any time without having to recreate the script button.</li>
<li>You can delete any script button by right-clicking on it.</li>
<li>On startup, the scripting plugin scans the entire .leo file and creates a script button
for every node whose headline starts with <tt class="docutils literal"><span class="pre">&#64;button</span> <span class="pre">scriptName</span></tt>.
<strong>Warning</strong>: this is indeed a security risk of the kind discussed later.
This feature can be disabled by setting <tt class="docutils literal"><span class="pre">atButtonNodes</span> <span class="pre">=</span> <span class="pre">True</span></tt> at the start of <tt class="docutils literal"><span class="pre">mod_scripting.py</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id34" id="test-and-suite-nodes" name="test-and-suite-nodes">&#64;test and &#64;suite nodes</a></h2>
<p><tt class="docutils literal"><span class="pre">&#64;test</span></tt> and <tt class="docutils literal"><span class="pre">&#64;suite</span></tt> nodes are a major advance in unit testing. Such nodes
have headlines that start with <tt class="docutils literal"><span class="pre">&#64;test</span></tt> or <tt class="docutils literal"><span class="pre">&#64;suite</span></tt>. The file <tt class="docutils literal"><span class="pre">test.leo</span></tt>
contains many examples of <tt class="docutils literal"><span class="pre">&#64;test</span></tt> and <tt class="docutils literal"><span class="pre">&#64;suite</span></tt> nodes. <tt class="docutils literal"><span class="pre">&#64;test</span></tt> and
<tt class="docutils literal"><span class="pre">&#64;suite</span></tt> nodes are a direct outgrowth of script buttons. The <tt class="docutils literal"><span class="pre">unit</span> <span class="pre">test</span></tt>
script button in <tt class="docutils literal"><span class="pre">test.leo</span></tt> scans the selected outline, creating one unit test
for each <tt class="docutils literal"><span class="pre">test</span></tt> node and zero or more unit tests for each <tt class="docutils literal"><span class="pre">&#64;suite</span></tt> node. The
<tt class="docutils literal"><span class="pre">unit</span> <span class="pre">test</span></tt> script then runs all the selected unit tests.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">&#64;test</span></tt> nodes</dt>
<dd><p class="first"><tt class="docutils literal"><span class="pre">&#64;test</span></tt> nodes create a single unit test from the script in its body
<strong>without having to create a subclass of unittest.TestCase</strong>.
For example, here is a complete unit test.  The headline is:</p>
<pre class="literal-block">
&#64;test p.t == p.v.t
</pre>
<p>The body text is:</p>
<pre class="literal-block">
# NOTE: p.__getattr__ must be enabled for this test to work.
root = c.rootPosition()
for p in root.allNodes_iter():
    assert(p.t == p.v.t)
</pre>
<p><strong>That's all!</strong> The headline marks the node as containing a unit test.
The body text contains the meat of the test.  No cruft at all!</p>
<p class="last"><strong>Notes</strong>: The unit tests created from <tt class="docutils literal"><span class="pre">&#64;test</span></tt> nodes define <tt class="docutils literal"><span class="pre">setUp</span></tt> and
<tt class="docutils literal"><span class="pre">tearDown</span></tt> methods. These methods ensure that the script being executed is
the presently selected node. The scripts in <tt class="docutils literal"><span class="pre">&#64;test</span></tt> nodes can not override
the <tt class="docutils literal"><span class="pre">setUp</span></tt> and <tt class="docutils literal"><span class="pre">tearDown</span></tt> methods. In practice, this is not a problem
because the scripts in <tt class="docutils literal"><span class="pre">&#64;test</span></tt> nodes are typically very simple. Such
scripts can use try/finally if they need to clean up after themselves.
Scripts in <tt class="docutils literal"><span class="pre">&#64;test</span></tt> nodes often assume that descendant nodes hold test
data. Scripts in <tt class="docutils literal"><span class="pre">&#64;test</span></tt> nodes can generally define and use sections, but
scripts may not use the <tt class="docutils literal"><span class="pre">&#64;others</span></tt> directive if descendant nodes hold
data.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">&#64;suite</span></tt> nodes</dt>
<dd><p class="first"><tt class="docutils literal"><span class="pre">&#64;suite</span></tt> are an easy way to run legacy unit tests. The <tt class="docutils literal"><span class="pre">Unit</span> <span class="pre">Test</span></tt>
button assumes that the body text of an <tt class="docutils literal"><span class="pre">&#64;suite</span></tt> node is a script that
creates a test suite and leaves the result in <tt class="docutils literal"><span class="pre">g.app.scriptDict['suite']</span></tt>.
<tt class="docutils literal"><span class="pre">test.leo</span></tt> several examples of <tt class="docutils literal"><span class="pre">&#64;suite</span> <span class="pre">nodes</span></tt>.
Here is an <tt class="docutils literal"><span class="pre">&#64;suite</span></tt> node that executes all doctests in Leo's sources.
The headline is:</p>
<pre class="literal-block">
&#64;suite run all doctests
</pre>
<p>The body text is:</p>
<pre class="literal-block">
import unittest
import leoTest
import sys

# DocTestSuite exists in Python 2.3 and above.
if g.CheckVersion(sys.version, &quot;2.3&quot;):
    path = g.os_path_join(g.app.loadDir,&quot;..&quot;,&quot;src&quot;)
    modules = leoTest.importAllModulesInPath(path)
    suite = leoTest.createUnitTestsFromDoctests(modules)
    if suite:
        g.app.scriptDict['suite'] = suite
else:
    # Create an empty suite to suppress a warning.
    g.app.scriptDict['suite'] = unittest.TestSuite()
    print &quot;Can't create unit tests from doctests&quot;
    print &quot;doctest.DocTestSuite requires Python 2.3 or above.&quot;
</pre>
<p>The real work of creating the test suites is done by
<tt class="docutils literal"><span class="pre">leoTest.createUnitTestsFromDoctests</span></tt>.
<strong>Important</strong>: if the suite was created successfully, the script must pass the suite
to script in the <tt class="docutils literal"><span class="pre">unit</span> <span class="pre">test</span></tt> script button by as follows:</p>
<pre class="last literal-block">
g.app.scriptDict['suite'] = suite
</pre>
</dd>
<dt><tt class="docutils literal"><span class="pre">&#64;button</span> <span class="pre">unit</span> <span class="pre">test</span></tt></dt>
<dd><p class="first">The script in the <tt class="docutils literal"><span class="pre">Unit</span> <span class="pre">Test</span></tt> script button in <tt class="docutils literal"><span class="pre">test.leo</span></tt> is just:</p>
<pre class="literal-block">
import leoTest
leoTest.doTests(all=False)
</pre>
<p class="last"><tt class="docutils literal"><span class="pre">test.leo</span></tt> defines the <tt class="docutils literal"><span class="pre">leoTest</span></tt> module. The <tt class="docutils literal"><span class="pre">doTests</span></tt> function is the
code that supports <tt class="docutils literal"><span class="pre">&#64;test</span></tt> and <tt class="docutils literal"><span class="pre">&#64;suite</span></tt> nodes. <strong>Important</strong>: you could
customize how <tt class="docutils literal"><span class="pre">&#64;test</span></tt> and <tt class="docutils literal"><span class="pre">&#64;suite</span></tt> nodes work by using your own script
in the <tt class="docutils literal"><span class="pre">&#64;button</span> <span class="pre">unit</span> <span class="pre">test</span></tt> node.</p>
</dd>
</dl>
<hr class="docutils" />
<p><a class="reference" href="design.html"><img alt="back" src="arrow_lt.gif" /></a> <a class="reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference" href="customizing.html"><img alt="next" src="arrow_rt.gif" /></a></p>
</div>
</div>
</div>
</body>
</html>
