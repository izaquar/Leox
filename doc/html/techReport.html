<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>The Essentials of Leo</title>
<style type="text/css">

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



</style>
</head>
<body>
<div class="document" id="the-essentials-of-leo">
<h1 class="title">The Essentials of Leo</h1>

<!-- rst3: filename: html\techReport.html -->
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#leo-s-window-outlines-clones" id="id1" name="id1">Leo’s window, outlines &amp; clones</a></li>
<li><a class="reference" href="#relations-organizer-nodes-views-tasks-and-metadata" id="id2" name="id2">Relations: organizer nodes, views, tasks and metadata</a></li>
<li><a class="reference" href="#plugins" id="id3" name="id3">Plugins</a></li>
<li><a class="reference" href="#derived-files-and-special-nodes" id="id4" name="id4">Derived files and special nodes</a></li>
<li><a class="reference" href="#markup-for-scripts" id="id5" name="id5">Markup for scripts</a></li>
<li><a class="reference" href="#scripting-leo" id="id6" name="id6">Scripting Leo</a></li>
<li><a class="reference" href="#leo-s-modules-and-classes" id="id7" name="id7">Leo’s modules and classes</a></li>
<li><a class="reference" href="#predefined-symbols-in-scripts" id="id8" name="id8">Predefined symbols in scripts</a></li>
<li><a class="reference" href="#accessing-data" id="id9" name="id9">Accessing data</a></li>
<li><a class="reference" href="#traversing-outlines" id="id10" name="id10">Traversing outlines</a></li>
<li><a class="reference" href="#executing-commands-from-scripts" id="id11" name="id11">Executing commands from scripts</a></li>
<li><a class="reference" href="#bringing-scripts-to-data" id="id12" name="id12">Bringing scripts to data</a></li>
<li><a class="reference" href="#unit-testing-with-test-and-suite-nodes" id="id13" name="id13">Unit Testing with &#64;test and &#64;suite nodes</a></li>
<li><a class="reference" href="#plugins-and-hooks" id="id14" name="id14">Plugins and hooks</a></li>
<li><a class="reference" href="#contacts" id="id15" name="id15">Contacts</a></li>
</ul>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id1" id="leo-s-window-outlines-clones" name="leo-s-window-outlines-clones">Leo’s window, outlines &amp; clones</a></h1>
<p>Leo organizes all data into nodes containing a <strong>headline</strong>, an expandable page of
<strong>body text</strong> and a (possibly empty) subtree of <strong>descendant nodes</strong>. The <strong>contents</strong> of a
node are its headline and body text. Leo’s main window contains an <strong>outline</strong> pane
at the top left, a <strong>log pane</strong> at the top right, and a <strong>body pane</strong> at the bottom. The
outline pane shows headlines; the body pane shows the body text of the selected
headline. The log pane displays messages from Leo.</p>
<p>Small red arrows mark <strong>cloned nodes</strong> (clones). Clones share the same content and
descendants. All clones of the same node are equivalent, so changing the
contents of one node (call it node N) changes the contents of all clones of N.
Furthermore, inserting, deleting or changing any descendant of node N causes the
corresponding insertion, deletion or change in all other clones of N.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id2" id="relations-organizer-nodes-views-tasks-and-metadata" name="relations-organizer-nodes-views-tasks-and-metadata">Relations: organizer nodes, views, tasks and metadata</a></h1>
<p>Clones allow you to organize data in multiple ways within the same outline. You
do not have to choose a single ‘correct’ organization: you can organize your
data in as many ways as you like.</p>
<p>You can use <strong>organizer nodes</strong> to create explicit relations (relationships) among
the data in your outline. The headline of the organizer node is the
relationship’s name. Now make clones of nodes from other parts of the outline
that participate in the relation. Drag the newly created clones so they become
children of the organizer node. You may want to create other (non-cloned)
children of the organizer node that contain data found nowhere else in the
outline. Voilà: you have just created the set of all nodes that pertain to the
relationship. The organizer node is the relation; the terms relation,
relationship and organizer node are interchangeable.</p>
<p>Three kinds of relations deserve special mention. A <strong>view</strong> is a relation (an
organizer node) containing all nodes related to a desired view (or slice) of the
data in the outline. Similarly, a <strong>task</strong> is an organizer node containing all nodes
related to a task. Relations are not limited to tasks or views: the notion of
relationship is completely general. Headlines naturally describe the data in
body text. That is, nodes relate <strong>metadata</strong> (descriptions of data) to data.
Separating data from metadata is useful for humans. It is even more valuable for
scripts: scripts can access data and metadata without complex parsing.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id3" id="plugins" name="plugins">Plugins</a></h1>
<p>Plugins are Python (.py) files contained in Leo’s plugins folder. Users can
write plugins to change how Leo works and to add new features without changing
Leo’s core code. We’ll discuss plugins in more detail later.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id4" id="derived-files-and-special-nodes" name="derived-files-and-special-nodes">Derived files and special nodes</a></h1>
<p>Leo can generate many external files called <strong>derived files</strong> from an outline. Leo
outlines can organize files throughout your computer’s file system. Nodes whose
headlines start with ‘&#64;’ are special nodes. Several <strong>special nodes</strong> indicate the
root of a tree that generates a derived file:</p>
<pre class="literal-block">
&#64;asis filename    Creates a derived file. Ignores all markup in body text.
&#64;file filename    Creates a derived file. Duplicates outline structure in .leo file.
&#64;noref filename   Creates a derived file. Ignores all section references.
&#64;nosent filename  Creates a derived file without sentinels.
&#64;thin filename    (Recommended) Like &#64;file, but thin derived files contain all outline structure.
</pre>
<p>Leo recognizes several other special nodes:</p>
<pre class="literal-block">
&#64;settings   Defines settings local to the .leo file.
&#64;url url    Double-clicking the node’s icon opens the url in Leo or in a browser.
</pre>
<p>The scripting plugin scans for the following nodes when opening an outline:</p>
<pre class="literal-block">
&#64;button         Creates a button in the **icon area** at the top of the Leo window.
&#64;plugin plugin  Enables a plugin if the plugin has not already been enabled.
&#64;script         Executes a script when opening the outline. This is a security risk: it is disabled by default.
</pre>
<p>Plugins, &#64;button nodes and &#64;script nodes can create other kinds of special nodes:</p>
<pre class="literal-block">
&#64;suite       Creates a suite of unit tests from script in body. Requires scripting plugin.
&#64;test        Creates a unit text from script in body. Requires scripting plugin.
&#64;rst         Outputs a tree containing markup for reStructuredText. Requires rst2 plugin.
&#64;run command Double clicking the node’s icon executes the command.  Requires run_nodes plugin.
</pre>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id5" id="markup-for-scripts" name="markup-for-scripts">Markup for scripts</a></h1>
<p>Leo’s Execute Script command <strong>preprocesses</strong> the script to be executed by scanning
a node N and its descendants looking for markup. <strong>Markup</strong> is special syntax that
controls this preprocessing. If node N contains no markup, the resulting script
is just N’s body text. Otherwise, the preprocessed script will include text from
descendant nodes as described below. The main kinds of markup are <strong>section
references</strong>, <strong>directives</strong> and <strong>doc parts</strong>.</p>
<ol class="arabic">
<li><p class="first"><strong>Section references</strong> have the form:</p>
<pre class="literal-block">
&lt;&lt;section name&gt;&gt;
</pre>
<p>The <tt class="docutils literal"><span class="pre">&lt;&lt;</span></tt> and <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt> must appear on the same line. Conversely, any line
containing <tt class="docutils literal"><span class="pre">&lt;&lt;</span></tt> and <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt> is a section reference, regardless of context. However,
section references are not recognized in doc parts. Any characters may appear
between <tt class="docutils literal"><span class="pre">&lt;&lt;</span></tt> and <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt>.</p>
<p>Section references are functional pseudo-code: while preprocessing a script, Leo
replaces section references by the actual text of the section’s definition.
Sections are defined in <strong>section definition nodes</strong>, whose headlines start with a
section reference and whose body text defines the section. Each section
definition node must descend from the node containing the section reference.</p>
</li>
<li><p class="first"><strong>Directives</strong> start with ‘&#64;’ in the leftmost column of body text. Directives
specify options and control Leo’s operation. The <tt class="docutils literal"><span class="pre">&#64;others</span></tt> directive is the
minimal markup needed to organize scripts. <tt class="docutils literal"><span class="pre">&#64;others</span></tt> tells Leo to insert the
preprocessed text of all descendant nodes (except section definition nodes) at
the spot at which the <tt class="docutils literal"><span class="pre">&#64;others</span></tt> directive occurs. Nodes are inserted in <strong>outline
order</strong>, the order in which nodes appear in the outline. <strong>Important</strong>: Leo adds the
whitespace preceding the <tt class="docutils literal"><span class="pre">&#64;others</span></tt> directive to the indentation of all
preprocessed text.</p>
<p>Using <tt class="docutils literal"><span class="pre">&#64;others</span></tt> is more convenient than using section references. Use <tt class="docutils literal"><span class="pre">&#64;others</span></tt> when
the order of included text does not matter:</p>
<pre class="literal-block">
class myClass:
        &#64;others # Include the methods of the class. Order doesn’t matter.
</pre>
<p>Use section references when the order of included text does matter. In the following script, for example,
&lt;&lt; imports &gt;&gt; ensures that imports come first. The <tt class="docutils literal"><span class="pre">&#64;others</span></tt> directive then includes the body text of all other
descendant nodes:</p>
<pre class="literal-block">
&#64;language python
&lt;&lt; imports&gt;&gt;
&#64;others # Define classes &amp; functions in child nodes.
main()
</pre>
<p>Here is a list of all of Leo’s standard directives:</p>
<pre class="literal-block">
&#64;whitespace (or &#64;doc)   Starts a doc part &amp; ends code part.
&#64;all                    Like &#64;others, but includes all descendant nodes.
&#64;c, &#64;code               Starts a code part and ends a doc part.
&#64;color                  Enables syntax coloring.
&#64;delims                 Temporarily changes comment delims.
&#64;nocolor, &#64;killcolor    Disables syntax coloring.
&#64;comment                Sets comment delimiters in external (derived) files.
&#64;language languagename  Sets language for syntax coloring and comments.
&#64;lineending lineending  Sets ending of lines in derived files.
&#64;others                 Inserts body text of all descendants except definition nodes.
&#64;pagewidth n            Sets page width for justifying comments in doc parts.
&#64;path path              Sets prefix to use in relative file names in &#64;file nodes, etc.
&#64;root filename          Marks the root of a tree that creates an external file.
&#64;raw, &#64;end_raw          Inhibits sections references in a range of text. (&#64;file only.)
&#64;tabwidth n             Sets width of tabs (negative widths convert tabs to spaces.)
&#64;wrap, &#64;nowrap          Controls wrapping of text in body pane.
</pre>
</li>
<li><p class="first">Doc parts start with the ‘&#64;’ directive and continue until the end of the body text or until the ‘&#64;c’ directive.
Body text not in a doc part is in a code part. Here is an example of a doc part:</p>
<pre class="literal-block">
&#64; This is a doc part. Doc parts may span many lines. Leo converts doc parts to comments.
Leo reformats the doc part by justifying lines so they are no longer than the page width.
&#64;c
</pre>
<p>Leo reformats doc parts by justifying the text into comment lines.
The <tt class="docutils literal"><span class="pre">&#64;pagewidth</span></tt> directive controls the length of these comment lines.
The <tt class="docutils literal"><span class="pre">&#64;language</span></tt> and <tt class="docutils literal"><span class="pre">&#64;comment</span></tt> directives specify the comment delimiters used in doc parts.</p>
</li>
</ol>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id6" id="scripting-leo" name="scripting-leo">Scripting Leo</a></h1>
<p>The <tt class="docutils literal"><span class="pre">Execute</span> <span class="pre">Script</span></tt> command preprocesses the selected text of the presently
selected outline node, or the entire text of the node if there is no selected
text. See the section called <tt class="docutils literal"><span class="pre">Markup</span> <span class="pre">for</span> <span class="pre">Scripts</span></tt> for a discussion of how Leo
preprocesses scripts. That section also discusses how Leo organizes scripts
using outlines. Conversely, scripts can use outlines to organize their data. To
write such scripts you must understand at least the basics of Leo’s modules and
classes...</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id7" id="leo-s-modules-and-classes" name="leo-s-modules-and-classes">Leo’s modules and classes</a></h1>
<p>Leo’s source code is organized as a collection of modules. The following
paragraphs describe five of the most important modules. See <tt class="docutils literal"><span class="pre">LeoPy.leo</span></tt> (Leo’s
full source code) for more details: scripts have full access to all of Leo’s
classes and data.</p>
<ol class="arabic simple">
<li>The <strong>leoGlobals</strong> module contains utility functions.
By convention, in Leo’s code <tt class="docutils literal"><span class="pre">g</span></tt> is always the <tt class="docutils literal"><span class="pre">leoGlobals</span></tt> module.</li>
<li>The <strong>leoApp</strong> module defines a class representing the entire Leo application.
<strong>g.app</strong> is the singleton object of this class: the application object.
The instance variables (ivars) of the application object are Leo’s global variables.</li>
<li>The leoCommands module defines the Commands class.
A commander is an instance of this class.
Commanders contain the operations that can be performed on a particular outline.
Each open Leo outline has its own commander.
By convention, in Leo’s code <strong>c</strong> is always a commander.</li>
<li>The leoFrame module defines the base leoFrame class for objects that create and manage
the visual appearance of Leo’s windows and panes.
The <strong>leoTkinterFrame</strong> and <strong>leoTkinterTree</strong> modules contain subclasses of the base classes in the leoFrame module.
A frame (an instance of the leoFrame class, or a subclass)
contains all the internal data needed to manage a Leo window.
<strong>c.frame</strong> is the frame associated with commander c.
If <strong>f</strong> is a frame, <strong>f.c</strong> is the frame’s commander, <strong>f.body</strong> is the frame’s body pane,
<strong>f.tree</strong> is the frame’s outline pane, and <strong>f.log</strong> is the frame’s log pane.</li>
<li>The leoNodes module defines several classes that implement Leo’s fundamental data structures.
These classes are complex.
Happily, scripts can and should ignore these complications by accessing nodes using
high-level methods of the position class.</li>
</ol>
<p>A <strong>position</strong> (an instance of the position class) is the state of some traversal of an outline. Equivalently, a position is a particular visual place in an outline. Cloned nodes may appear many times in an outline. Non-cloned nodes may also appear in many places: consider a non-cloned descendant of a cloned node. By convention, in Leo’s source code p is a position.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id8" id="predefined-symbols-in-scripts" name="predefined-symbols-in-scripts">Predefined symbols in scripts</a></h1>
<p>When executing scripts Leo predefines the following three symbols:
<strong>c</strong> is the commander of the outline in which the script is defined,
<strong>g</strong> is the leoGlobals module and
<strong>p</strong> is the position of the selected node in c’s outline, i.e., <tt class="docutils literal"><span class="pre">c.currentPosition()</span></tt>.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id9" id="accessing-data" name="accessing-data">Accessing data</a></h1>
<p>Scripts should get and set data using high-level access methods. Here are some important getters:</p>
<pre class="literal-block">
g.app                The application object. Its ivars are Leo’s global variables.
g.app.windowList     The list of all open frames.
c.currentPosition()  The position of the selected node.
c.rootPosition()     The position of the first node in the outline.
p.headString()       The headline of position p.
p.bodyString()       The body text of position p.
p.childIndex()       The number of siblings that precede p.
p.numberOfChildren() The number of p’s children.
p.level()            The number of p’s ancestors.
p.hasChildren()      True if p has children.
p.isAncestorOf(p2)   True if p2 is a child, grandchild, etc. of p.
p.isCloned()         True if p is a clone.
p.isDirty()          True if p’s contents have been changed.
p.isExpanded()       True if p has children and p’s outline is expanded.
p.isMarked()         True if p’s headline is marked.
p.isVisible()        True if all of p’s ancestors are expanded.
</pre>
<p>And here are some important setters:</p>
<pre class="literal-block">
c.setBodyString(p,s) Set body text of p to s.
c.setHeadString(p,s) Set headline of p to s.
</pre>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id10" id="traversing-outlines" name="traversing-outlines">Traversing outlines</a></h1>
<p>Scripts can visit some or all of the nodes of a Leo outline using the following iterators:</p>
<pre class="literal-block">
c.allNodes_iter             # All positions in the outline, in outline order.
p.children_iter()           # All children of p.
p.parents_iter()            # All parents of p.
p.siblings_iter()           # All siblings of p, including p.
p.following_siblings_iter() # All siblings following p, not including p.
</pre>
<p>For example, the following prints all the nodes of an outline, properly indented:</p>
<pre class="literal-block">
for p in c.allNodes_iter():
    print ' '*p.level(), p.headString()
</pre>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id11" id="executing-commands-from-scripts" name="executing-commands-from-scripts">Executing commands from scripts</a></h1>
<p>Scripts may open other Leo outlines, or execute any of Leo’s commands.  Here are some examples:</p>
<pre class="literal-block">
ok,frame = g.openWithFileName(path,c)       # Opens the .leo file found at path.
c.deleteOutline()   # Deletes the selected node.
c.insertHeadline()  # Inserts a new node after present position.
</pre>
<p>For more examples, see <tt class="docutils literal"><span class="pre">Chapter</span> <span class="pre">7:</span> <span class="pre">Scripting</span> <span class="pre">Leo</span> <span class="pre">with</span> <span class="pre">Python</span></tt>, in <tt class="docutils literal"><span class="pre">Leo’s</span> <span class="pre">Users</span> <span class="pre">Guide</span></tt>.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id12" id="bringing-scripts-to-data" name="bringing-scripts-to-data">Bringing scripts to data</a></h1>
<p>The scripting plugin creates two buttons in the icon area at the top of the Leo
window. The <tt class="docutils literal"><span class="pre">Run</span> <span class="pre">Script</span></tt> button executes the script in the selected node just
like the <tt class="docutils literal"><span class="pre">Execute</span> <span class="pre">Script</span></tt> command. The <tt class="docutils literal"><span class="pre">Script</span> <span class="pre">Button</span></tt> button creates a new
button whose headline is the headline of the presently selected node, call it
node N. Pressing this button executes the script in node N with p predefined as
<tt class="docutils literal"><span class="pre">c.currentPosition()</span></tt> at the time the script is executed. This clever trick
brings the script to the data in the selected outline.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id13" id="unit-testing-with-test-and-suite-nodes" name="unit-testing-with-test-and-suite-nodes">Unit Testing with &#64;test and &#64;suite nodes</a></h1>
<p><tt class="docutils literal"><span class="pre">test.leo</span></tt> contains all of Leo’s unit tests. An <tt class="docutils literal"><span class="pre">&#64;button</span> <span class="pre">node</span></tt> in test.leo
creates a blue <tt class="docutils literal"><span class="pre">Unit</span> <span class="pre">Test</span></tt> button in the icon area. This button is an
excellent example of bringing scripts to data. The <tt class="docutils literal"><span class="pre">Unit</span> <span class="pre">Test</span></tt> button executes
all the unit tests specified by <tt class="docutils literal"><span class="pre">&#64;test</span></tt> and <tt class="docutils literal"><span class="pre">&#64;suite</span></tt> nodes in the selected
outline. <strong>Important</strong>: <tt class="docutils literal"><span class="pre">&#64;button</span></tt>, <tt class="docutils literal"><span class="pre">&#64;test</span></tt> and <tt class="docutils literal"><span class="pre">&#64;suite</span></tt> nodes require the
scripting plugin to be enabled.</p>
<p><tt class="docutils literal"><span class="pre">&#64;test</span></tt> nodes greatly simplify unit testing. The <tt class="docutils literal"><span class="pre">Unit</span> <span class="pre">Test</span></tt> button creates
a unit test from the body text of each <tt class="docutils literal"><span class="pre">&#64;test</span></tt> node. In effect, the <tt class="docutils literal"><span class="pre">Unit</span>
<span class="pre">Test</span></tt> button automatically creates an instance of <tt class="docutils literal"><span class="pre">unittest.TestCase</span></tt> whose
run method is the body text of the &#64;test node. There is no need to create
<tt class="docutils literal"><span class="pre">TestCase</span></tt> objects explicitly!</p>
<p><tt class="docutils literal"><span class="pre">&#64;suite</span></tt> nodes support legacy unit tests. When the <tt class="docutils literal"><span class="pre">Unit</span> <span class="pre">Test</span></tt> script button
finds an <tt class="docutils literal"><span class="pre">&#64;suite</span> <span class="pre">node</span></tt> it executes the script in its body text. This script
should create a suite of unit tests and set:</p>
<pre class="literal-block">
g.app.scriptDict['suite'] = suite
</pre>
<p>where suite is the created suite. The <tt class="docutils literal"><span class="pre">Unit</span> <span class="pre">Test</span></tt> button then runs that
created suite of unit tests.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id14" id="plugins-and-hooks" name="plugins-and-hooks">Plugins and hooks</a></h1>
<p>Plugins are Python (.py) files in Leo’s plugin subdirectory. It is easy to
create new plugins: Leo’s users have contributed dozens of plugins that extend
Leo’s capabilities in new ways. Leo imports all enabled plugins during startup.
The file pluginsManager.txt lists all enabled plugins. You can use the plugin
manager plugin to control plugins without updating <tt class="docutils literal"><span class="pre">pluginsManager.txt</span></tt> by hand.</p>
<p>Plugins can override any class, method or function in Leo’s core, the files in
Leo’s src subdirectory (the files derived from LeoPy.leo). Besides altering
Leo’s core, plugins can register functions called hooks that Leo calls at
various times during Leo’s execution. Events that trigger hooks include key
pressed events, screen drawing events, node selection events and many others.
When importing a plugin, Leo will call the top-level init() function if it
exists. This function should register the plugin’s hooks by calling
leoPlugins.registerHandler.</p>
<p>For full details about hooks and events see <tt class="docutils literal"><span class="pre">Chapter</span> <span class="pre">13:</span> <span class="pre">Writing</span> <span class="pre">Plugins</span></tt>, in
<tt class="docutils literal"><span class="pre">Leo’s</span> <span class="pre">Users</span> <span class="pre">Guide</span></tt>. The file <tt class="docutils literal"><span class="pre">leoPlugins.leo</span></tt> contains all plugins that are
presently distributed with Leo; studying these plugins is a good way of learning
to write your own plugins.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id15" id="contacts" name="contacts">Contacts</a></h1>
<ul class="simple">
<li>Leo’s home page:  google edreamleo or <a class="reference" href="http://webpages.charter.net/edreamleo/front.html">http://webpages.charter.net/edreamleo/front.html</a></li>
<li>Edward K. Ream:  <a class="reference" href="mailto:edreamleo&#64;charter.net">edreamleo&#64;charter.net</a>, 166 N. Prospect Ave., Madison WI 53726, (608) 231-0766</li>
</ul>
</div>
</div>
</body>
</html>
