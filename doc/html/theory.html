<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title></title>
<style type="text/css">

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



</style>
</head>
<body>
<div class="document">


<!-- rst3: filename: html\theory.html -->
<p><a class="reference" href="history.html"><img alt="back" src="arrow_lt.gif" /></a> <a class="reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference" href="whitepapers.html"><img alt="next" src="arrow_rt.gif" /></a></p>
<div class="section">
<h1><a class="toc-backref" href="#id1" id="chapter-10-theory-of-operation" name="chapter-10-theory-of-operation">Chapter 10: Theory of Operation</a></h1>
<p>This chapter discusses how Leo's code works,
paying particular attention to topics that have caused difficulties in design or implementation.
This chapter will be of use primarily to those wanting to change Leo's code.</p>
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#chapter-10-theory-of-operation" id="id1" name="id1">Chapter 10: Theory of Operation</a><ul>
<li><a class="reference" href="#overview" id="id2" name="id2">Overview</a></li>
<li><a class="reference" href="#nodes" id="id3" name="id3">Nodes</a></li>
<li><a class="reference" href="#drawing-and-events" id="id4" name="id4">Drawing and events</a></li>
<li><a class="reference" href="#clones" id="id5" name="id5">Clones</a></li>
<li><a class="reference" href="#find-and-change-commands" id="id6" name="id6">Find and change commands</a></li>
<li><a class="reference" href="#tangle-and-untangle-commands" id="id7" name="id7">Tangle and untangle commands</a></li>
<li><a class="reference" href="#unicode" id="id8" name="id8">Unicode</a></li>
<li><a class="reference" href="#unlimited-undo" id="id9" name="id9">Unlimited undo</a></li>
<li><a class="reference" href="#key-bindings" id="id10" name="id10">Key bindings</a></li>
</ul>
</li>
</ul>
</div>
<!-- WARNING: image targets may not have upper case letters! -->
<div class="section">
<h2><a class="toc-backref" href="#id2" id="overview" name="overview">Overview</a></h2>
<p>All versions of Leo are organized as a collection of classes. The general
organization of Leo has remained remarkably stable throughout all versions of
Leo, although the names of classes are different in different versions.
Smalltalk's Model/View/Controller terminology is a good way think about Leo's
classes. <strong>Model classes</strong> represent the fundamental data. The vnode and tnode
classes are Leo's primary model classes.</p>
<p><strong>View classes</strong> draw the screen. The main view classes are leoFrame.py and
leoTree.py. The colorizer class in leoColor.py handles syntax coloring in the
body pane. Leo's view classes know about data stored in the vnode class. Most
events (keystrokes and mouse actions) in the outline and body pane are handled
in the leoTree class. The leoFrame class also creates the Leo window, including
menus, and dispatches the appropriate members of the controller classes in
response to menu commands.</p>
<p><strong>Controller classes</strong> (aka commanders) control the application. In Leo,
controllers mostly handle menu commands. Commanders create subcommanders to
handle complex commands. The atFile class reads and writes files derived from
<tt class="docutils literal"><span class="pre">&#64;file</span></tt> trees. The LeoFind class handles the Find and Change commands. The
leoImportCommands class handles the Import and Export commands, the
tangleCommands class handles the Tangle and Untangle commands and the undoer
class handles the Undo command. Other classes could be considered controller
classes.</p>
<p>Each Leo window has its own commander and subcommanders. Subcommanders are not
subclasses of their commander. Instead, subcommanders know the commander that
created them, and call that commander as needed. Commanders and subcommanders
call the model and view classes as needed. For example, the Commands class
handles outline commands. To move a headline, the commander for the window calls
a vnode move routine to alter the data, then calls the view class to redraw the
screen based on the new data.</p>
<p>A singleton instance of the <strong>LeoApp</strong> class represents the application itself.
All code uses the app() global function to gain access to this singleton member.
The ivars of the LeoApp object are the equivalent of Leo's global variables.
leo.py uses no global Python variables, except the gApp variable returned by
app(). leoGlobals.py defines all application constants. Naturally, most
constants are local to the class that uses them.</p>
<p>Several classes combine aspects of model, view and controller. For example, the
<strong>LeoPrefs</strong> class represents user preferences (model), the Preference Panel
(view) and the Preferences menu command (controller). Similarly, the <strong>LeoFind</strong>
class represents find settings, the Find/Change dialog, and the Find/Change
commands.</p>
<p>We use the following convention throughout this documentation. Any variable
named <tt class="docutils literal"><span class="pre">c</span></tt> is a commander, i.e., an instance of the Commands class in
<tt class="docutils literal"><span class="pre">leoCommands.py</span></tt>. Variables named <tt class="docutils literal"><span class="pre">v</span></tt> and <tt class="docutils literal"><span class="pre">t</span></tt> are vnodes and tnodes respectively.
These classes are defined in <tt class="docutils literal"><span class="pre">leoNodes.py</span></tt>.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id3" id="nodes" name="nodes">Nodes</a></h2>
<p>The vnode and tnode classes represent most of the data contained in the outline.
These classes are Leo's fundamental Model classes. A <strong>vnode</strong> (visual node)
represents a headline at a particular location on the screen. When a headline is
cloned, vnodes must be copied. vnodes persist even if they are not drawn on the
screen. Commanders call vnode routines to insert, delete and move headlines.</p>
<p>The vnode contains data associated with a headline, except the body text data
which is contained in tnodes. A vnode contains headline text, a link to its
tnode and other information. Vnodes contain structure links: parent, firstChild,
next and back ivars. To insert, delete, move or clone a vnode the vnode class
just alters those links. The Commands class calls the <strong>leoTree</strong> class to redraw
the outline pane whenever it changes. The leoTree class knows about these
structure links; in effect, the leoTree and vnode classes work together.</p>
<p>A <strong>tnode</strong>, (text node) represents body text. All vnodes that are clones of
each other share the same tnode. In other words, tnodes are the unit of sharing
of body text. The tnode class is more private than the vnode class. Most
commanders deal only with vnodes, though there are exceptions.</p>
<p>Because Leo has unlimited Undo commands, Leo deletes vnodes and tnodes only when
a window closes. Leo deletes nodes indirectly using <tt class="docutils literal"><span class="pre">destroy</span></tt> methods. Several
classes, including the vnode, tnode, leoFrame and leoTree classes, have
<tt class="docutils literal"><span class="pre">destroy</span></tt> methods. <tt class="docutils literal"><span class="pre">destroy</span></tt> methods merely clear links so that Python's and
Tkinter's reference counting mechanisms will eventually delete vnodes, tnodes
and other data when a window closes.</p>
<p>Leo's XML file format uses <strong>tnode indices</strong> to indicate which tnodes (t
elements) belong to which vnodes (v elements). Such indices are required. Even
if we duplicated the body text of shared tnodes within the file, the file format
would still need an unambiguous way to denote that tnodes are shared. Present
versions of Leo use <strong>gnx's</strong> (global node indices) as node indices. These indices
do not change once a node has created. This reduces cvs conflicts.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id4" id="drawing-and-events" name="drawing-and-events">Drawing and events</a></h2>
<p>Leo must redraw the outline pane when commands are executed and as the result of mouse and keyboard events.
The main challenges are eliminating flicker and handling events properly.
These topics are interrelated.</p>
<p><strong>Eliminating flicker</strong>. Leo must update the outline pane with minimum flicker.
Various versions of Leo have approached this problem in different ways. The
drawing code in leo.py is robust, flexible, relatively simple and should work in
almost any conceivable environment. Leo assumes that all code that changes the
outline pane will be enclosed in matching calls to the c.beginUpdate and
c.endUpdate methods of the Commands class. c.beginUpdate() inhibits drawing
until the matching c.endUpdate(). These calls may be nested; only the outermost
call to c.endUpdate() calls c.redraw() to force a redraw of the outline pane.</p>
<p>Code may call <tt class="docutils literal"><span class="pre">c.endUpdate(flag)</span></tt> instead of <tt class="docutils literal"><span class="pre">c.endUpdate()</span></tt>. Leo redraws
the screen only if flag is true. This allows code to suppress redrawing entirely
when needed. For example, here is how the idle_body_key event handler in
leoTree.py conditionally redraws the outline pane:</p>
<pre class="literal-block">
redraw_flag = false
c.beginUpdate()
val = v.computeIcon()
if val != v.iconVal:
        v.iconVal = val
        redraw_flag = true
c.endUpdate(redraw_flag) # redraw only if necessary
</pre>
<p>The leoTree class redraws all icons automatically when <tt class="docutils literal"><span class="pre">c.redraw()</span></tt> is called.
This is a major simplification compared to previous versions of Leo. The entire
machinery of drawing icons in the vnode class has been eliminated. The
<tt class="docutils literal"><span class="pre">v.computeIcon</span></tt> method tells what the icon should be. The <tt class="docutils literal"><span class="pre">v.iconVal</span></tt> ivar
tells what the present icon is. The event handler simply compares these two
values and sets <tt class="docutils literal"><span class="pre">redraw_flag</span></tt> if they don't match.</p>
<p><strong>Handling events.</strong> Besides redrawing the screen, Leo must handle events or
commands that change the text in the outline or body panes. It is surprisingly
difficult to ensure that headline and body text corresponds to the vnode and
tnode corresponding to presently selected outline, and vice versa. For example,
when the user selects a new headline in the outline pane, we must ensure that 1)
the vnode and tnode of the previously selected node have up-to-date information
and 2) the body pane is loaded from the correct data in the corresponding tnode.
Early versions of Leo attempted to satisfy these conditions when the user
switched outline nodes. Such attempts never worked well; there were too many
special cases. Later versions of Leo, including leo.py, use a much more direct
approach. The event handlers make sure that the vnode and tnode corresponding to
the presently selected node are always kept up-to-date. In particular, every
keystroke in the body pane causes the presently selected tnode to be updated
immediately. There is no longer any need for the <tt class="docutils literal"><span class="pre">c.synchVnode</span></tt> method, though
that method still exists for compatibility with old scripts.</p>
<p>The leoTree class contains all the event handlers for the body and outline
panes. The actual work is done in the <tt class="docutils literal"><span class="pre">idle_head_key</span></tt> and <tt class="docutils literal"><span class="pre">idle_body_key</span></tt> methods.
These routines are surprisingly complex; they must handle all the tasks
mentioned above, as well as others. The <tt class="docutils literal"><span class="pre">idle_head_key</span></tt> and <tt class="docutils literal"><span class="pre">idle_body_key</span></tt> methods
should not be called outside the leoTree class. However, it often happens that
code that handles user commands must simulate an event. That is, the code needs
to indicate that headline or body text has changed so that the screen may be
redrawn properly. The leoTree class defines the following simplified event
handlers: <tt class="docutils literal"><span class="pre">onBodyChanged</span></tt>, <tt class="docutils literal"><span class="pre">onBodyWillChange</span></tt>, <tt class="docutils literal"><span class="pre">onBodyKey</span></tt>, <tt class="docutils literal"><span class="pre">onHeadChanged</span></tt> and
<tt class="docutils literal"><span class="pre">onHeadlineKey</span></tt>. Commanders and subcommanders call these event handlers to
indicate that a command has changed, or will change, the headline or body text.
Calling event handlers rather than <tt class="docutils literal"><span class="pre">c.beginUpdate</span></tt> and <tt class="docutils literal"><span class="pre">c.endUpdate</span></tt> ensures that
the outline pane is redrawn only when needed.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id5" id="clones" name="clones">Clones</a></h2>
<p>Leo now represents clones by sharing tnodes. Cloned vnodes share the same tnode.
This shared tnode represents the entire shared subtree of both clones. Thus, the
<tt class="docutils literal"><span class="pre">_firstChild</span></tt> link must reside in <em>tnodes</em>, not <em>vnodes</em>.</p>
<p>Because vnodes may be visited many times during a complete traversal of a tree,
a vnode no longer represents a unique location on the screen. As a result, the
<strong>position</strong> class had to be invented. <tt class="docutils literal"><span class="pre">c.rootVnode</span></tt> and <tt class="docutils literal"><span class="pre">c.currentVnode</span></tt>
now return <em>positions</em> instead of vnodes. The position class was designed to
allow compatibility with old scripts. Old code can use positions just like they
used to use vnodes.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id6" id="find-and-change-commands" name="find-and-change-commands">Find and change commands</a></h2>
<p>The find and change commands are tricky; there are many details that must be
handled properly. The following principles govern the LeoFind class:</p>
<ol class="arabic simple">
<li>Find and Change commands initialize themselves using only the state of the
present Leo window. In particular, the Find class must not save internal
state information from one invocation to the next. This means that when the
user changes the nodes, or selects new text in headline or body text, those
changes will affect the next invocation of any Find or Change command.
Failure to follow this principle caused all kinds of problems in the Borland
and Macintosh codes. There is one exception to this rule: we must remember
where interactive wrapped searches start. This principle simplifies the code
because most ivars do not persist. However, each command must ensure that
the Leo window is left in a state suitable for restarting the incremental
(interactive) Find and Change commands. Details of initialization are
discussed below.</li>
<li>The Find and Change commands must not change the state of the outline or body
pane during execution. That would cause severe flashing and slow down the
commands a great deal. In particular, the <tt class="docutils literal"><span class="pre">c.selectPosition</span></tt> and <tt class="docutils literal"><span class="pre">c.editPosition</span></tt>
methods must not be called while looking for matches.</li>
<li>When incremental Find or Change commands succeed they must leave the Leo
window in the proper state to execute another incremental command. We
restore the Leo window as it was on entry whenever an incremental search
fails and after any Find All and Change All command. Initialization involves
setting the <tt class="docutils literal"><span class="pre">self.c</span></tt>, <tt class="docutils literal"><span class="pre">self.v</span></tt>, <tt class="docutils literal"><span class="pre">self.in_headline</span></tt>, <tt class="docutils literal"><span class="pre">self.wrapping</span></tt> and
<tt class="docutils literal"><span class="pre">self.s_text</span></tt> ivars.</li>
</ol>
<p>Setting <tt class="docutils literal"><span class="pre">self.in_headline</span></tt> is tricky; we must be sure to retain the state of
the outline pane until initialization is complete. Initializing the Find All and
Change All commands is much easier because such initialization does not depend
on the state of the Leo window. Using Tk.Text widgets for both headlines and
body text results in a huge simplification of the code.</p>
<p>Indeed, the searching code does not know whether it is searching headline or
body text. The search code knows only that <tt class="docutils literal"><span class="pre">self.s_text</span></tt> is a Tk.Text widget that
contains the text to be searched or changed and the insert and sel Tk attributes
of self.search_text indicate the range of text to be searched. Searching
headline and body text simultaneously is complicated. The selectNextVnode()
method handles the many details involved by setting <tt class="docutils literal"><span class="pre">self.s_text</span></tt> and its insert
and sel attributes.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id7" id="tangle-and-untangle-commands" name="tangle-and-untangle-commands">Tangle and untangle commands</a></h2>
<p>This section describes Leo's explicit <tt class="docutils literal"><span class="pre">Tangle</span></tt> and <tt class="docutils literal"><span class="pre">Untangle</span></tt> commands. Such
commands operate only on <tt class="docutils literal"><span class="pre">&#64;root</span></tt> and <tt class="docutils literal"><span class="pre">&#64;unit</span></tt> trees. The previous chapter discusses
the implicit Tangle on Write/Untangle on Read processes used to read and write
<tt class="docutils literal"><span class="pre">&#64;file</span></tt> trees.</p>
<p>The <tt class="docutils literal"><span class="pre">Tangle</span></tt> command translates the selected <tt class="docutils literal"><span class="pre">&#64;root</span></tt> tree into one or more
well-formatted C source files. The outline should contain directives, sections
references and section definitions, as described in Chapter 4. The Untangle
command is essentially the reverse of the <tt class="docutils literal"><span class="pre">Tangle</span></tt> command. The Tangle command
creates a derived file from an <tt class="docutils literal"><span class="pre">&#64;root</span></tt> tree; the Untangle command incorporates
changes made to derived files back into the <tt class="docutils literal"><span class="pre">&#64;root</span></tt> tree.</p>
<p>The <tt class="docutils literal"><span class="pre">Tangle</span></tt> command operates in two passes. The first pass discovers the complete
definitions of all sections and places these definitions in a symbol table. The
first pass also makes a list of root sections. Definitions can appear in any
order, so we must scan the entire input file to know whether any particular
definition has been completed.</p>
<p>This second pass creates one file for each <tt class="docutils literal"><span class="pre">&#64;root</span></tt> node. <tt class="docutils literal"><span class="pre">Tangle</span></tt> rescans each
section in the list of roots, copying the root text to the output and replacing
each section reference by the section's definition. This is a recursive process
because any definition may contain other references. We can not allow a section
to be defined in terms of itself, either directly or indirectly. We check for
such illegally recursive definitions in pass 2 using the section stack class.
<tt class="docutils literal"><span class="pre">Tangle</span></tt> indicates where sections begin and end using comment lines called
sentinel lines. The this part of the appendix discusses the format of the
sentinels output by the <tt class="docutils literal"><span class="pre">Tangle</span></tt> command.</p>
<p>The key design principle of the <tt class="docutils literal"><span class="pre">Tangle</span></tt> command is this:</p>
<pre class="literal-block">
Tangle must output newlines in a context-free manner.
</pre>
<p>That is, <tt class="docutils literal"><span class="pre">Tangle</span></tt> must never output conditional newlines, either directly or
indirectly. Without this rule <tt class="docutils literal"><span class="pre">Untangle</span></tt> could not determine whether to skip or
copy newlines.</p>
<p>The <tt class="docutils literal"><span class="pre">Tangle</span></tt> command increases the indentation level of a section expansion the
minimum necessary to align the section expansion with the surrounding code. In
essence, this scheme aligns all section expansions with the line of code in
which the reference to the section occurs. In some cases, several nested
sections expansions will have the same indentation level. This can occur, for
example, when a section reference in an outline occurs at the left margin of the
outline.</p>
<p>This scheme is probably better than more obvious schemes that indent more
&quot;consistently.&quot; Such schemes would produce too much indentation for deeply
nested outlines. The present scheme is clear enough and avoids indentation
wherever possible, yet indents sections adequately. End sentinel lines make this
scheme work by making clear where the expansion of one section ends and the
expansion of a containing section resumes.</p>
<p><tt class="docutils literal"><span class="pre">Tangle</span></tt> increases indentation if the section reference does not start a line.
Untangle is aware of this hack and adjusts accordingly. This extra indentation
handles several common code idioms, which otherwise would create under-indented
code. In short, <tt class="docutils literal"><span class="pre">Tangle</span></tt> produces highly readable output, given the necessity
of preserving newlines for <tt class="docutils literal"><span class="pre">Untangle</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">Untangle</span></tt> is inherently complex. It must do a perfect job of updating the
outline, especially whitespace, from expansions of section definitions created
by the Tangle command. Such expansions need not be identical because they may
have been generated at different levels of indentation. The <tt class="docutils literal"><span class="pre">Untangle</span></tt> command
can not assume that all expansions of a section will be identical in the derived
file; within the derived file, the programmer may have made incompatible changes
to two different expansions of the same section. <tt class="docutils literal"><span class="pre">Untangle</span></tt> must check to see
that all expansions of a section are &quot;equivalent&quot;. As an added complication,
derived files do not contain all the information found in <tt class="docutils literal"><span class="pre">&#64;root</span></tt> trees.
<tt class="docutils literal"><span class="pre">&#64;root</span></tt> trees may contain headlines that generate no code at all. Also, an
outline may define a section in several ways: with an <tt class="docutils literal"><span class="pre">&#64;c</span></tt> or <tt class="docutils literal"><span class="pre">&#64;code</span></tt>
directive or with a section definition line. To be useful, Untangle must handle
all these complications flawlessly. The this part of the appendix discusses the
various conventions used in the sentinels output by the <tt class="docutils literal"><span class="pre">Tangle</span></tt> command.
These conventions allow the <tt class="docutils literal"><span class="pre">Untangle</span></tt> command to recreate whitespace
correctly.</p>
<p><tt class="docutils literal"><span class="pre">Untangle</span></tt> operates in two passes. The first pass finds definitions in the
derived file and enters them into the <strong>Untangle Symbol Table</strong>, or UST.
Definitions often include references to other sections, so definitions often
include nested definitions of referenced sections. The first pass uses a
definition stack to keep track of nested definitions. The top of the stack
represents the definition following the latest reference, except for the very
first entry pushed on the stack, which represents the code in the outline that
contains the <tt class="docutils literal"><span class="pre">&#64;root</span></tt> directive. The stack never becomes empty because of the
entry for the <tt class="docutils literal"><span class="pre">&#64;root</span></tt> section. All definitions of a section should
match--otherwise there is an inconsistent definition. This pass uses a forgiving
compare routine that ignores differences that do not affect the meaning of a
program.</p>
<p>The second pass of <tt class="docutils literal"><span class="pre">Untangle</span></tt> enters definitions from the outline into the
<strong>Tangle Symbol Table</strong>, or TST. The second pass simultaneously updates all
sections in the outline whose definition in the TST does not match the
definition in the UST. The central coding insight of the Untangle command is
this:  <strong>the second pass of Untangle is almost identical to the first pass of
Tangle</strong>. That is, <tt class="docutils literal"><span class="pre">Tangle</span></tt> and <tt class="docutils literal"><span class="pre">Untangle</span></tt> share key parts of code, namely the
<tt class="docutils literal"><span class="pre">skip_body</span></tt> method and its allies. Just when <tt class="docutils literal"><span class="pre">skip_body</span></tt> enters a definition
into the symbol table, all the information is present that <tt class="docutils literal"><span class="pre">Untangle</span></tt> needs to
update that definition.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id8" id="unicode" name="unicode">Unicode</a></h2>
<p>Leo uses unicode objects in vnodes and tnodes to denote headline and body text.
Note that unicode strings have no encoding; only plain strings have encodings.
This means that once an (encoded) plain string has been converted to a unicode
string it doesn't matter how the unicode string was created. This is the key
that makes Leo's new code robust: internally Leo never has to worry about
encodings. Encoding matter only when encoded strings are converted to and from
Unicode. This happens when Leo reads or writes files.</p>
<p>Python expressions that mix unicode strings u and plain strings s, like one of these:</p>
<pre class="literal-block">
u + s
u == s
u[5] == s[2:]
</pre>
<p>are promoted to unicode objects using the &quot;system encoding&quot;. This encoding
should never be changed, but we can't assume that we know what it is, so for
safety we should assume the most restrictive encoding, namely &quot;ascii&quot;. With this
assumption, Leo's code can't throw an exception during these promotions provided
that:</p>
<ul class="simple">
<li>All strings are converted to unicode when Leo reads files or gets text from Tk.Text widgets.</li>
<li>All string literals in Leo's code have only ascii characters.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id9" id="unlimited-undo" name="unlimited-undo">Unlimited undo</a></h2>
<p>Unlimited undo is straightforward; it merely requires that all commands that
affect the outline or body text must be undoable. In other words, everything
that affects the outline or body text must be remembered. We may think of all
the actions that may be Undone or Redone as a string of beads (undo nodes).</p>
<p>Undoing an operation moves backwards to the next bead; redoing an operation moves
forwards to the next bead. A bead pointer points to the present bead. The bead
pointer points in front of the first bead when Undo is disabled. The bead
pointer points at the last bead when Redo is disabled. An undo node is a Python
dictionary containing all information needed to undo or redo the operation. The
Undo command uses the present bead to undo the action, then moves the bead
pointer backwards.</p>
<p>The Redo command uses the bead after the present bead to redo the action, then
moves the bead pointer forwards. All undoable operations call setUndoParams() to
create a new bead. The list of beads does not branch; all undoable operations
(except the Undo and Redo commands themselves) delete any beads following the
newly created bead. I did not invent this model of unlimited undo.
I first came across it in the documentation for Apple's Yellow Box classes.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id10" id="key-bindings" name="key-bindings">Key bindings</a></h2>
<p>leoKeys.py handles key bindings.
There are two kinds of bindings, gui bindings and pane bindings.</p>
<p><strong>Gui bindings</strong> are the actual binding as seen by Tkinter (or whatever gui is in effect).
Leo binds every key that has a binding to k.masterKeyHander.
For Tkinter, a <em>separate</em> binding must be made, rather than a single &lt;Key&gt; binding,
because, alas, Tkinter key events provide insufficient enough information
to tell what key actually caused the key event(!)
This is a significant hole in Tkinter's event mechanism.</p>
<p>At present Leo makes gui bindings in several places, all equivalent.
Bindings are made to callbacks, all of which have this form:</p>
<pre class="literal-block">
def callback(event=None,k=k,stroke=stroke):
   return k.masterKeyHandler(event,stroke)
</pre>
<p>As a result, changing gui bindings actually has no effect whatever.
It would be clearer to have a single place to make these bindings...</p>
<p>In any case, the purpose of these callbacks is to capture the value of 'stroke' so
that it can be passed to k.masterKeyHandler.
This relieves k.masterKeyHandler of the impossible task of computing the stroke from the event.
<strong>Important</strong>:  No function argument is ever passed to k.masterKeyHandler from these callbacks,
because k.masterKeyHandler binds keys to command handlers as described next.</p>
<p><strong>Pane bindings</strong> are bindings represented by various Python dictionaries in the keyHandlerClass
(see below).
k.masterKeyHandler and its helpers use these dictionaries to call the proper command or mode handler.
This logic is hairy, but it is completely separate from the gui binding logic.</p>
<p>Here are the dictionaries that k.masterKeyHandler uses:</p>
<ul class="simple">
<li>c.commandsDict:
Keys are minibuffer command names; values are functions f.</li>
<li>k.inverseCommandsDict:
Keys are f.__name__l values are emacs command names.</li>
<li>k.bindingsDict:
Keys are shortcuts; values are <em>lists</em> of g.bunch(func,name,warningGiven).</li>
<li>k.masterBindingsDict:
Keys are pane names: 'all','text',etc. or mode names.
Values are dicts:  keys are strokes; values are g.Bunch(commandName,func,pane,stroke).</li>
<li>k.modeWidgetsDict:
Keys are mode names; values are lists of widgets to which bindings have been made.</li>
<li>k.settingsNameDict:
Keys are lowercase settings; values are 'real' Tk key specifiers.
Important: this table has no inverse.</li>
<li>inverseBindingDict:
This is <em>not</em> an ivar; it is computed by k.computeInverseBindingDict().
Keys are emacs command names; values are <em>lists</em> of shortcuts.</li>
</ul>
<hr class="docutils" />
<p><a class="reference" href="history.html"><img alt="back" src="arrow_lt.gif" /></a> <a class="reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference" href="whitepapers.html"><img alt="next" src="arrow_rt.gif" /></a></p>
</div>
</div>
</div>
</body>
</html>
