<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title></title>
<style type="text/css">

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



</style>
</head>
<body>
<div class="document">


<!-- rst3: filename: html\writingPlugins.html -->
<!-- June 8, 2006 -->
<p><a class="reference" href="plugins.html"><img alt="back" src="arrow_lt.gif" /></a> <a class="reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference" href="rstplugin3.html"><img alt="next" src="arrow_rt.gif" /></a></p>
<div class="section">
<h1><a class="toc-backref" href="#id1" id="chapter-13-writing-plugins" name="chapter-13-writing-plugins">Chapter 13: Writing Plugins</a></h1>
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#chapter-13-writing-plugins" id="id1" name="id1">Chapter 13: Writing Plugins</a><ul>
<li><a class="reference" href="#overview" id="id2" name="id2">Overview</a></li>
<li><a class="reference" href="#important-security-warnings" id="id3" name="id3">Important security warnings</a></li>
<li><a class="reference" href="#writing-plugins-and-hooks" id="id4" name="id4">Writing plugins and hooks</a></li>
<li><a class="reference" href="#summary-of-hooks" id="id5" name="id5">Summary of hooks</a></li>
<li><a class="reference" href="#convenience-routines-for-plugins" id="id6" name="id6">Convenience routines for plugins</a></li>
<li><a class="reference" href="#support-for-unit-testing" id="id7" name="id7">Support for unit testing</a></li>
<li><a class="reference" href="#how-to-make-operations-undoable" id="id8" name="id8">How to make operations undoable</a></li>
<li><a class="reference" href="#turning-script-buttons-into-plugins" id="id9" name="id9">Turning script buttons into plugins</a></li>
</ul>
</li>
</ul>
</div>
<!-- External links... -->
<!-- Relative links... -->
<!-- WARNING: image targets may not have upper case letters! -->
<div class="section">
<h2><a class="toc-backref" href="#id2" id="overview" name="overview">Overview</a></h2>
<p>A <strong>plugin</strong> is a Python file that appears in Leo's plugin directory. Plugins
are a powerful way of enhancing and customizing Leo. The file
<tt class="docutils literal"><span class="pre">pluginsManager.txt</span></tt> in the plugins directory controls tells which plugins are
enabled. Midway during startup, Leo imports all enabled plugins. Plugins can
register functions called <strong>hooks</strong> that are to be run at specified times.
Plugins can:</p>
<ul class="simple">
<li>add new commands</li>
<li>modify how existing commands work</li>
<li>add new menus or customize existing menus.</li>
<li>override any of Leo's core code&gt;</li>
</ul>
<p>Here are some important features of plugins:</p>
<ul class="simple">
<li>Plugins can use any of Leo's source code for their own use.
Doing so is easy: after importing one of Leo's modules the plugin can call any routine in that module.
This documentation describes <strong>convenience methods</strong> in Leo's core that were created the use of plugins.</li>
<li>Plugins are permanent: they will not go away when Leo is updated.</li>
<li>Leo loads plugins in the order in which they appear in <tt class="docutils literal"><span class="pre">pluginsManager.txt.</span></tt>
Leo disables all plugins if <tt class="docutils literal"><span class="pre">pluginsManager.txt</span></tt> does not exist in the plugins directory.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id3" id="important-security-warnings" name="important-security-warnings">Important security warnings</a></h2>
<p>Naively using plugins can expose you and your .leo files to malicious attacks.
The fundamental principles are:</p>
<pre class="literal-block">
Scripts and plugins must never blindly execute code from untrusted sources.
</pre>
<p>and:</p>
<pre class="literal-block">
.leo files obtained from other people may potentially contain hostile code.
</pre>
<p>Stephen Schaefer summarizes the danger this way:</p>
<pre class="literal-block">
I foresee a future in which the majority of leo projects come from
marginally trusted sources...a world of leo documents sent hither and yon -
resumes, project proposals, textbooks, magazines, contracts - and as a race
of Pandora's, we cannot resist wanting to see &quot;What's in the box?&quot; And are
we going to fire up a text editor to make a detailed examination of the
ASCII XML? Never! We're going to double click on the cute leo file icon, and
leo will fire up in all its raging glory. Just like Word (and its macros) or
Excel (and its macros).
</pre>
<p>In other words:</p>
<pre class="literal-block">
When we share &quot;our&quot; .leo files we can NOT assume that
we know what is in our &quot;own&quot; documents!
</pre>
<p>Not all environments are untrustworthy. Code in a commercial cvs repository is
probably trustworthy: employees might be terminated for posting malicious code.
Still, the potential for abuse exists anywhere.</p>
<p>In Python it is very easy to write a script that will blindly execute other scripts:</p>
<pre class="literal-block">
# Warning: extremely dangerous code

# Execute the body text of all nodes that start with `&#64;script`.
def onLoadFile():
    for p in c.allNodes_iter():
        h = p.headString().lower()
        if g.match_word(h,0,&quot;&#64;script&quot;):
            s = p.bodyString()
            if s and len(s) &gt; 0:
                try: # SECURITY BREACH: s may be malicious!
                    exec(s + '\n')
                except:
                    es_exception()
</pre>
<p>Executing this kind of code is typically an intolerable security risk.
<strong>Important</strong>: rexec provides <em>no protection whatever</em>.
Leo is a repository of source code, so any text operation is potentially malicious.
For example, consider the following script, which is valid in rexec mode:</p>
<pre class="literal-block">
badNode = c.currentPosition()
for p in c.allNodes_iter():
    &lt;&lt; change `rexec` to `exec` in p's body &gt;&gt;
&lt;&lt; delete badNode &gt;&gt;
&lt;&lt; clear the undo stack &gt;&gt;
</pre>
<p>This script will introduce a security hole the .leo file without doing anything
prohibited by rexec, and without leaving any traces of the perpetrating script
behind. The damage will become permanent <em>outside</em> this script when the user
saves the .leo file.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id4" id="writing-plugins-and-hooks" name="writing-plugins-and-hooks">Writing plugins and hooks</a></h2>
<p><tt class="docutils literal"><span class="pre">leoPlugins.leo</span></tt> contains all of Leo's official hooks. Studying this file is
the best way to learn how to write plugins.  This section discusses just a few details.</p>
<p>Leo attempts to import all enabled plugins at startup time.
Plugins register hooks with code such as:</p>
<pre class="literal-block">
leoPlugins.registerHandler(&quot;after-create-leo-frame&quot;,onCreate)
leoPlugins.registerHandler(&quot;idle&quot;, on_idle)
leoPlugins.registerHandler((&quot;start2&quot;,&quot;open2&quot;,&quot;command2&quot;), create_open_with_menu)
</pre>
<p>As shown above, a plugin may register one or more hooks with a single call to
<tt class="docutils literal"><span class="pre">leoPlugins.registerHandler</span></tt>. Once a hook is registered, Leo will call the
registered function' at the named <strong>hook time</strong>. For example:</p>
<pre class="literal-block">
leoPlugins.registerHandler(&quot;idle&quot;, on_idle)
</pre>
<p>causes Leo to call <tt class="docutils literal"><span class="pre">on_idle</span></tt> at &quot;idle&quot; time.</p>
<p>Hook functions must have the following signature:</p>
<pre class="literal-block">
def myHook (tag, keywords):
    whatever
</pre>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">tag</span></tt> is the name of the hook (a string).</li>
<li><tt class="docutils literal"><span class="pre">keywords</span></tt> is a Python dictionary containing additional information.
The following section describes the contents of the <tt class="docutils literal"><span class="pre">keywords</span></tt> dictionary in detail.</li>
</ul>
<p><strong>Important</strong>: hooks should get the proper commander this way:</p>
<pre class="literal-block">
c = keywords.get('c')
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id5" id="summary-of-hooks" name="summary-of-hooks">Summary of hooks</a></h2>
<p>Leo's core defines hook times using in many places. The following table tell all
about each hook: its name, when it is called, and the additional arguments
passed to the hook in the <tt class="docutils literal"><span class="pre">keywords</span></tt> dictionary. For some kind of hooks, Leo
will skip its own normal processing if the hook returns anything <em>other</em> than
None. The table indicates such hooks with 'yes' in the 'Stop?' column.</p>
<p><strong>Important</strong>: Ever since Leo 4.2, the <tt class="docutils literal"><span class="pre">v</span></tt>, <tt class="docutils literal"><span class="pre">old_v</span></tt> and <tt class="docutils literal"><span class="pre">new_v</span></tt> keys in
the keyword dictionary contain <em>positions</em>, not vnodes. These keys are
deprecated. The <tt class="docutils literal"><span class="pre">new_c</span></tt> key is also deprecated. Plugins should use the <tt class="docutils literal"><span class="pre">c</span></tt> key instead.</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="7%" />
<col width="30%" />
<col width="37%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Hook name (tag argument)</th>
<th class="head">Stop?</th>
<th class="head">When called</th>
<th class="head">Keys in keywords dict</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>'after-create-leo-frame'</td>
<td>&nbsp;</td>
<td>after creating any frame</td>
<td>c</td>
</tr>
<tr><td>'after-redraw-outline'</td>
<td>&nbsp;</td>
<td>end of tree.redraw</td>
<td>c (note 6)</td>
</tr>
<tr><td>'before-create-leo-frame'</td>
<td>&nbsp;</td>
<td>before frame.finishCreate</td>
<td>c</td>
</tr>
<tr><td>'bodyclick1'</td>
<td>yes</td>
<td>before normal click in body</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'bodyclick2'</td>
<td>&nbsp;</td>
<td>after normal click in body</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'bodydclick1'</td>
<td>yes</td>
<td>before double click in body</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'bodydclick2'</td>
<td>&nbsp;</td>
<td>after  double click in body</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'bodykey1'</td>
<td>yes</td>
<td>before body keystrokes</td>
<td>c,p,v,ch,oldSel,undoType</td>
</tr>
<tr><td>'bodykey2'</td>
<td>&nbsp;</td>
<td>after  body keystrokes</td>
<td>c,p,v,ch,oldSel,undoType</td>
</tr>
<tr><td>'bodyrclick1'</td>
<td>yes</td>
<td>before right click in body</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'bodyrclick2'</td>
<td>&nbsp;</td>
<td>after  right click in body</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'boxclick1'</td>
<td>yes</td>
<td>before click in +- box</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'boxclick2'</td>
<td>&nbsp;</td>
<td>after  click in +- box</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'clear-mark'</td>
<td>&nbsp;</td>
<td>when mark is set</td>
<td>c,p,v</td>
</tr>
<tr><td>'close-frame'</td>
<td>&nbsp;</td>
<td>in app.closeLeoWindow</td>
<td>c</td>
</tr>
<tr><td>'color-optional-markup'</td>
<td>yes *</td>
<td>(note 7)</td>
<td>colorer,p,v,s,i,j,colortag (note 7)</td>
</tr>
<tr><td>'command1'</td>
<td>yes</td>
<td>before each command</td>
<td>c,p,v,label (note 2)</td>
</tr>
<tr><td>'command2'</td>
<td>&nbsp;</td>
<td>after  each command</td>
<td>c,p,v,label (note 2)</td>
</tr>
<tr><td>'create-optional-menus'</td>
<td>&nbsp;</td>
<td>(note 8)</td>
<td>c (note 8)</td>
</tr>
<tr><td>'create-popup-menu-items'</td>
<td>&nbsp;</td>
<td>in tree.OnPopup</td>
<td>c,p,v,event (new)</td>
</tr>
<tr><td>'destroy-all-global-windows'</td>
<td>&nbsp;</td>
<td>(note 12)</td>
<td>None</td>
</tr>
<tr><td>'draw-outline-box'</td>
<td>yes</td>
<td>when drawing +- box</td>
<td>tree,p,v,x,y</td>
</tr>
<tr><td>'draw-outline-icon'</td>
<td>yes</td>
<td>when drawing icon</td>
<td>tree,p,v,x,y</td>
</tr>
<tr><td>'draw-outline-node'</td>
<td>yes</td>
<td>when drawing node</td>
<td>tree,p,v,x,y</td>
</tr>
<tr><td>'draw-outline-text-box'</td>
<td>yes</td>
<td>when drawing headline</td>
<td>tree,p,v,x,y</td>
</tr>
<tr><td>'drag1'</td>
<td>yes</td>
<td>before start of drag</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'drag2'</td>
<td>&nbsp;</td>
<td>after  start of drag</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'dragging1'</td>
<td>yes</td>
<td>before continuing to drag</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'dragging2'</td>
<td>&nbsp;</td>
<td>after  continuing to drag</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'enable-popup-menu-items'</td>
<td>&nbsp;</td>
<td>in tree.OnPopup</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'end1'</td>
<td>&nbsp;</td>
<td>start of app.quit()</td>
<td>None</td>
</tr>
<tr><td>'enddrag1'</td>
<td>yes</td>
<td>before end of drag</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'enddrag2'</td>
<td>&nbsp;</td>
<td>after  end of drag</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'headclick1'</td>
<td>yes</td>
<td>before normal click in headline</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'headclick2'</td>
<td>&nbsp;</td>
<td>after  normal click in headline</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'headrclick1'</td>
<td>yes</td>
<td>before right click in headline</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'headrclick2'</td>
<td>&nbsp;</td>
<td>after  right click in headline</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'headkey1'</td>
<td>yes</td>
<td>before headline keystrokes</td>
<td>c,p,v,ch (note 13)</td>
</tr>
<tr><td>'headkey2'</td>
<td>&nbsp;</td>
<td>after  headline keystrokes</td>
<td>c,p,v,ch (note 13)</td>
</tr>
<tr><td>'hypercclick1'</td>
<td>yes</td>
<td>before control click in hyperlink</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'hypercclick2'</td>
<td>&nbsp;</td>
<td>after  control click in hyperlink</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'hyperenter1'</td>
<td>yes</td>
<td>before entering hyperlink</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'hyperenter2'</td>
<td>&nbsp;</td>
<td>after  entering hyperlink</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'hyperleave1'</td>
<td>yes</td>
<td>before leaving  hyperlink</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'hyperleave2'</td>
<td>&nbsp;</td>
<td>after  leaving  hyperlink</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'iconclick1'</td>
<td>yes</td>
<td>before single click in icon box</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'iconclick2'</td>
<td>&nbsp;</td>
<td>after  single click in icon box</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'iconrclick1'</td>
<td>yes</td>
<td>before right click in icon box</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'iconrclick2'</td>
<td>&nbsp;</td>
<td>after  right click in icon box</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'icondclick1'</td>
<td>yes</td>
<td>before double click in icon box</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'icondclick2'</td>
<td>&nbsp;</td>
<td>after  double click in icon box</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'idle'</td>
<td>&nbsp;</td>
<td>periodically (at idle time)</td>
<td>c</td>
</tr>
<tr><td>'init-color-markup'</td>
<td>&nbsp;</td>
<td>(note 7)</td>
<td>colorer,p,v (note 7)</td>
</tr>
<tr><td>'menu1'</td>
<td>yes</td>
<td>before creating menus</td>
<td>c,p,v (note 3)</td>
</tr>
<tr><td>'menu2'</td>
<td>yes</td>
<td>before updating menus</td>
<td>c,p,v</td>
</tr>
<tr><td>'new'</td>
<td>&nbsp;</td>
<td>start of New command</td>
<td>c,old_c,new_c (note 9)</td>
</tr>
<tr><td>'open1'</td>
<td>yes</td>
<td>before opening any file</td>
<td>c,old_c,new_c,fileName (note 4)</td>
</tr>
<tr><td>'open2'</td>
<td>&nbsp;</td>
<td>after  opening any file</td>
<td>c,old_c,new_c,fileName (note 4)</td>
</tr>
<tr><td>'openwith1'</td>
<td>yes</td>
<td>before Open With command</td>
<td>c,p,v,openType,arg,ext</td>
</tr>
<tr><td>'openwith2'</td>
<td>&nbsp;</td>
<td>after  Open With command</td>
<td>c,p,v,openType,arg,ext</td>
</tr>
<tr><td>'recentfiles1'</td>
<td>yes</td>
<td>before Recent Files command</td>
<td>c,p,v,fileName,closeFlag</td>
</tr>
<tr><td>'recentfiles2'</td>
<td>&nbsp;</td>
<td>after  Recent Files command</td>
<td>c,p,v,fileName,closeFlag</td>
</tr>
<tr><td>'redraw-entire-outline'</td>
<td>yes</td>
<td>start of tree.redraw</td>
<td>c (note 6)</td>
</tr>
<tr><td>'save1'</td>
<td>yes</td>
<td>before any Save command</td>
<td>c,p,v,fileName</td>
</tr>
<tr><td>'save2'</td>
<td>&nbsp;</td>
<td>after  any Save command</td>
<td>c,p,v,fileName</td>
</tr>
<tr><td>'scan-directives'</td>
<td>&nbsp;</td>
<td>in scanDirectives</td>
<td>c,p,v,s,old_dict,dict,pluginsList (note 10)</td>
</tr>
<tr><td>'select1'</td>
<td>yes</td>
<td>before selecting a position</td>
<td>c,new_p,old_p,new_v,new_v</td>
</tr>
<tr><td>'select2'</td>
<td>&nbsp;</td>
<td>after  selecting a position</td>
<td>c,new_p,old_p,new_v,old_v</td>
</tr>
<tr><td>'select3'</td>
<td>&nbsp;</td>
<td>after  selecting a position</td>
<td>c,new_p,old_p,new_v,old_v</td>
</tr>
<tr><td>'set-mark'</td>
<td>&nbsp;</td>
<td>when a mark is set</td>
<td>c,p,v</td>
</tr>
<tr><td>'show-popup-menu'</td>
<td>&nbsp;</td>
<td>in tree.OnPopup</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'start1'</td>
<td>&nbsp;</td>
<td>after app.finishCreate()</td>
<td>None</td>
</tr>
<tr><td>'start2'</td>
<td>&nbsp;</td>
<td>after opening first Leo window</td>
<td>c,p,v,fileName</td>
</tr>
<tr><td>'unselect1'</td>
<td>yes</td>
<td>before unselecting a vnode</td>
<td>c,new_p,old_p,new_v,old_v</td>
</tr>
<tr><td>'unselect2'</td>
<td>&nbsp;</td>
<td>after  unselecting a vnode</td>
<td>c,new_p,old_p,old_v,old_v</td>
</tr>
<tr><td>'&#64;url1'</td>
<td>yes</td>
<td>before double-click &#64;url node</td>
<td>c,p,v,url (note 5)</td>
</tr>
<tr><td>'&#64;url2'</td>
<td>&nbsp;</td>
<td>after  double-click &#64;url node</td>
<td>c,p,v(note 5)</td>
</tr>
</tbody>
</table>
<p><strong>Notes</strong>:</p>
<ol class="arabic">
<li><p class="first">'activate' and 'deactivate' hooks have been removed because they do not work as expected.</p>
</li>
<li><p class="first">'commands' hooks: The label entry in the keywords dict contains the
'canonicalized' form of the command, that is, the lowercase name of the command
with all non-alphabetic characters removed.
Commands hooks now set the label for undo and redo commands 'undo' and 'redo'
rather than 'cantundo' and 'cantredo'.</p>
</li>
<li><p class="first">'menu1' hook: Setting <tt class="docutils literal"><span class="pre">g.app.realMenuNameDict</span></tt> in this hook is an easy way of
translating menu names to other languages. <strong>Note</strong>: the 'new' names created this
way affect only the actual spelling of the menu items, they do <em>not</em> affect how
you specify shortcuts settings, nor do they affect the 'official'
command names passed in <tt class="docutils literal"><span class="pre">g.app.commandName</span></tt>. For example:</p>
<pre class="literal-block">
app().realMenuNameDict['Open...'] = 'Ouvre'.
</pre>
</li>
<li><p class="first">'open1' and 'open2' hooks: These are called with a keywords dict containing the following entries:</p>
<ul class="simple">
<li>c:          The commander of the newly opened window.</li>
<li>old_c:      The commander of the previously open window.</li>
<li>new_c:      (deprecated: use 'c' instead) The commander of the newly opened window.</li>
<li>fileName:   The name of the file being opened.</li>
</ul>
<p>You can use <tt class="docutils literal"><span class="pre">old_c.currentPosition()</span></tt> and <tt class="docutils literal"><span class="pre">c.currentPosition()</span></tt> to get the current
position in the old and new windows.
Leo calls the 'open1' and 'open2' hooks only if the file is not already open. Leo
will also call the 'open1' and 'open2' hooks if: a) a file is opened using the
Recent Files menu and b) the file is not already open.</p>
</li>
<li><p class="first">'&#64;url1' and '&#64;url2' hooks are only executed if the 'icondclick1' hook returns None.</p>
</li>
<li><p class="first">These hooks are useful for testing.</p>
</li>
<li><p class="first">These hooks allow plugins to parse and handle markup within doc parts,
comments and Python <tt class="docutils literal"><span class="pre">'''</span></tt> strings. Note that these hooks are <em>not</em> called in
Python <tt class="docutils literal"><span class="pre">'''</span></tt> strings. See the color_markup plugin for a complete example of how to
use these hooks.</p>
</li>
<li><p class="first">Leo calls the 'create-optional-menus' hook when creating menus. This hook need
only create new menus in the correct order, without worrying about the placement
of the menus in the menu bar. See the plugins_menu and scripts_menu plugins for
examples of how to use this hook.</p>
</li>
<li><p class="first">The <tt class="docutils literal"><span class="pre">New</span></tt> command calls 'new'.
The 'new_c' key is deprecated.  Use the 'c' key instead.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">g.scanDirectives</span></tt> calls 'scan-directives' hook.
<tt class="docutils literal"><span class="pre">g.scanDirectives</span></tt> returns a dictionary, say d.
d.get('pluginsList') is an a list of tuples <tt class="docutils literal"><span class="pre">(d,v,s,k)</span></tt> where:</p>
<ul class="simple">
<li>d is the spelling of the &#64;directive, without the leading &#64;.</li>
<li>v is the vnode containing the directive, _not_ the original vnode.</li>
<li>s[k:] is a string containing whatever follows the &#64;directive.
k has already been moved past any whitespace that follows the &#64;directive.</li>
</ul>
<p>See the add_directives plugins directive for a complete example of how to use
the 'scan-directives' hook.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">g.app.closeLeoWindow</span></tt> calls the 'close-frame' hook just before
removing the window from <tt class="docutils literal"><span class="pre">g.app.windowList</span></tt>. The hook code may remove the window
from <tt class="docutils literal"><span class="pre">app.windowList</span></tt> to prevent <tt class="docutils literal"><span class="pre">g.app.closeLeoWindow</span></tt> from destroying the window.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">g.app.destroyAllGlobalWindows</span></tt> calls the 'destroy-all-global-windows' hook.
This hook gives plugins the chance to clean up after themselves when Leo shuts down.</p>
</li>
<li><p class="first">New in Leo 4.4: Leo calls the 'headkey1' and 'headkey2' hooks only when the user completes
the editing of a headline, and ch is always 'r', regardless of platform.</p>
</li>
</ol>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id6" id="convenience-routines-for-plugins" name="convenience-routines-for-plugins">Convenience routines for plugins</a></h2>
<p>The following methods exist for the convenience of plugins.</p>
<p><strong>g.enableIdleTimeHook(idleTimeDelay=100)</strong></p>
<p>Enables the &quot;idle&quot; hook. Afterwards, Leo will call the &quot;idle&quot; hook approximately every idleTimeDelay milliseconds.
Leo will continue to call the &quot;idle&quot; hook periodically until <tt class="docutils literal"><span class="pre">disableIdleTimeHook</span></tt> is called.</p>
<p><strong>g.disableIdleTimeHook()</strong></p>
<p>Disables the &quot;idle&quot; hook.</p>
<p><strong>c.frame.menu.createMenuItemsFromTable (self,menuName,table,openWith=0)</strong></p>
<p>This method adds items to the menu whose name is menuName.
The table argument describes the entries to be created.
This table is a sequence of items of the form <tt class="docutils literal"><span class="pre">(name,None,command)</span></tt>:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">name</span></tt> is the command name.</li>
<li><tt class="docutils literal"><span class="pre">None</span></tt> was a shortcut in previous versions of Leo, but shortcuts for user-defined commands
should now be defined in &#64;shortcuts nodes.</li>
<li><tt class="docutils literal"><span class="pre">command</span></tt> is the routine to execute when the menu item is selected.</li>
<li>An entry of the form <tt class="docutils literal"><span class="pre">(&quot;-&quot;,None,None)</span></tt> creates a separator line between menu items.</li>
</ul>
<p>For example:</p>
<pre class="literal-block">
table =
    (&quot;Toggle Active Pane&quot;,None,self.OnToggleActivePane),
    (&quot;-&quot;,None,None),
    (&quot;Toggle Split Direction&quot;,None,self.OnToggleSplitDirection))
c.frame.menu.createMenuItemsFromTable(&quot;Window&quot;,table)
</pre>
<p>If the <tt class="docutils literal"><span class="pre">openWith</span></tt> keyword argument is 1 the items are added to a submenu of the Open With menu.
However, it will be more convenient to use the <tt class="docutils literal"><span class="pre">createOpenWithMenuFromTable</span></tt> method to create the <tt class="docutils literal"><span class="pre">Open</span> <span class="pre">With</span></tt> menu.</p>
<p><strong>c.frame.createNewMenu (self,menuName,parentName=&quot;top&quot;)</strong></p>
<p>This method creates a new menu:</p>
<ul class="simple">
<li>menuName is the name of the menu to be created.</li>
<li>parentName is the name of the parent menu, or &quot;top&quot; if the menu is to created in the menu bar.</li>
</ul>
<p>This method returns the menu object that was created, or None if there was a problem.
Your code need not remember the value returned by this method.  Instead, your code will refer to menus by name.</p>
<p><strong>c.frame.createOpenWithMenuFromTable (self,table)</strong></p>
<p>This method adds items to submenu of the <tt class="docutils literal"><span class="pre">Open</span> <span class="pre">With</span></tt> menu item in the <tt class="docutils literal"><span class="pre">File</span></tt> menu.
The table argument describes the entries to be created.
This table is a sequence of items of the form <tt class="docutils literal"><span class="pre">(name,shortcut,data)</span></tt>:</p>
<ul class="simple">
<li>name is the command name</li>
<li>shortcut is the shortcut, or None to indicate no shortcut.</li>
<li>data is a tuple of the form (command,arg,ext)</li>
<li>command is one of &quot;os.system&quot;, &quot;os.startfile&quot;, &quot;os.spawnl&quot;, &quot;os.spawnv&quot; or &quot;exec&quot;.</li>
<li>arg is an argument to be passed to the given command.</li>
<li>ext is a file extension or None.</li>
</ul>
<p>When the user selects the <tt class="docutils literal"><span class="pre">Open</span> <span class="pre">With</span></tt> item corresponding to the table item Leo executes <tt class="docutils literal"><span class="pre">command(arg)</span></tt>.
If <tt class="docutils literal"><span class="pre">ext</span></tt> is not <tt class="docutils literal"><span class="pre">None</span></tt>, the temp file has the given extension.
Otherwise, Leo computes an extension based on what <tt class="docutils literal"><span class="pre">&#64;language</span></tt> directive is in effect.
For example:</p>
<pre class="literal-block">
table = (
    (&quot;Idle&quot;,   &quot;Alt+Shift+I&quot;,(&quot;os.system&quot;,idle_arg,&quot;.py&quot;)),
    (&quot;Word&quot;,   &quot;Alt+Shift+W&quot;,(&quot;os.startfile&quot;,None,&quot;.doc&quot;)),
    (&quot;Wordpad&quot;,&quot;Alt+Shift+T&quot;,(&quot;os.startfile&quot;,None,&quot;.txt&quot;)))

top().frame.createOpenWithMenuFromTable(table)
</pre>
<p><strong>c.frame.deleteMenu (self,menuName)</strong></p>
<p>Deletes the menu whose name is given, including all entries in the menu.</p>
<p><strong>c.frame.deleteMenuItem (self,itemName,menuName=&quot;top&quot;)</strong></p>
<p>Deletes the item whose name is itemName from the menu whose name is menuName.
To delete a menu in the menubar, specify <tt class="docutils literal"><span class="pre">menuName=&quot;top&quot;</span></tt>.</p>
<p><strong>c.frame.menu.setRealMenuNamesFromTable(table)</strong></p>
<p>Translates names of menus and menu items into another language.  For example:</p>
<pre class="literal-block">
table = (
    (&quot;Help&quot;, &quot;&amp;Aide&quot;),
    (&quot;About Leo...&quot;, &quot;Au &amp;sujet de Leo...&quot;),
    (&quot;Online Home Page&quot;, &quot;&amp;Page d'Accueil en ligne&quot;),
    (&quot;Open Online Tutorial&quot;, &quot;Ouvrir &amp;Tutoriel en ligne&quot;),
    (&quot;Open LeoDocs.leo&quot;, &quot;Ouvrir Leo&amp;Docs.leo&quot;),
    (&quot;Open LeoConfig.leo&quot;, &quot;Ouvrir Leo&amp;Config.leo&quot;),
    (&quot;Apply Settings&quot;, &quot;Appliquer les &amp;RÃ©glages&quot;),
)

c.frame.menu.setRealMenuNamesFromTable(table)
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id7" id="support-for-unit-testing" name="support-for-unit-testing">Support for unit testing</a></h2>
<p>The plugins test suite creates a new convention: if a plugin has a function at
the outer (module) level called <tt class="docutils literal"><span class="pre">unitTest</span></tt>, Leo will call that function when
doing unit testing for plugins. So it would be good if writers of plugins would
create such a <tt class="docutils literal"><span class="pre">unitTest</span> <span class="pre">function</span></tt>. To indicate a failure the <tt class="docutils literal"><span class="pre">unitTest</span></tt> just
throws an exception. Leo's plugins test suite takes care of the rest.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id8" id="how-to-make-operations-undoable" name="how-to-make-operations-undoable">How to make operations undoable</a></h2>
<p>Client code should call <tt class="docutils literal"><span class="pre">u.beforeX</span></tt> and <tt class="docutils literal"><span class="pre">u.afterX</span></tt> methods to create a bead
describing the operation that is being performed. <strong>Note</strong>: <tt class="docutils literal"><span class="pre">u</span></tt> is shorthand for
<tt class="docutils literal"><span class="pre">c.undoer</span></tt>. Most <tt class="docutils literal"><span class="pre">u.beforeX</span></tt> methods return <tt class="docutils literal"><span class="pre">undoData</span></tt> that the client
code merely passes to the corresponding <tt class="docutils literal"><span class="pre">u.afterX</span></tt> method. This data contains
the 'before' snapshot. The <tt class="docutils literal"><span class="pre">u.afterX</span></tt> methods then create a bead containing
both the 'before' and 'after' snapshots.</p>
<p><tt class="docutils literal"><span class="pre">u.beforeChangeGroup</span></tt> and <tt class="docutils literal"><span class="pre">u.afterChangeGroup</span></tt> allow multiple calls to
<tt class="docutils literal"><span class="pre">u.beforeX</span></tt> and <tt class="docutils literal"><span class="pre">u.afterX</span></tt> methods to be treated as a single undoable entry.
See the code for the <tt class="docutils literal"><span class="pre">Change</span> <span class="pre">All</span></tt>, <tt class="docutils literal"><span class="pre">Sort</span></tt>, <tt class="docutils literal"><span class="pre">Promote</span></tt> and <tt class="docutils literal"><span class="pre">Demote</span></tt>
commands for examples. The <tt class="docutils literal"><span class="pre">u.beforeChangeGroup</span></tt> and <tt class="docutils literal"><span class="pre">u.afterChangeGroup</span></tt>
methods substantially reduce the number of <tt class="docutils literal"><span class="pre">u.beforeX</span></tt> and <tt class="docutils literal"><span class="pre">afterX</span></tt> methods
needed.</p>
<p>Plugins may define their own <tt class="docutils literal"><span class="pre">u.beforeX</span></tt> and <tt class="docutils literal"><span class="pre">afterX</span></tt> methods. Indeed,
<tt class="docutils literal"><span class="pre">u.afterX</span></tt> merely needs to set the <tt class="docutils literal"><span class="pre">bunch.undoHelper</span></tt> and
<tt class="docutils literal"><span class="pre">bunch.redoHelper</span></tt> ivars to the methods used to undo and redo the operation.
See the code for the various <tt class="docutils literal"><span class="pre">u.beforeX</span></tt> and <tt class="docutils literal"><span class="pre">afterX</span></tt> methods for guidance.</p>
<p><tt class="docutils literal"><span class="pre">p.setDirty</span></tt> and <tt class="docutils literal"><span class="pre">p.setAllAncestorAtFileNodesDirty</span></tt> now return a
<tt class="docutils literal"><span class="pre">dirtyVnodeList</span></tt> that all vnodes that became dirty as the result of an
operation. More than one list may be generated: client code is responsible for
merging lists using the pattern <tt class="docutils literal"><span class="pre">dirtyVnodeList.extend(dirtyVnodeList2)</span></tt></p>
<p>See the section <tt class="docutils literal"><span class="pre">&lt;&lt;</span> <span class="pre">How</span> <span class="pre">Leo</span> <span class="pre">implements</span> <span class="pre">unlimited</span> <span class="pre">undo</span> <span class="pre">&gt;&gt;</span></tt> in <tt class="docutils literal"><span class="pre">leoUndo.py</span></tt>
for more details. In general, the best way to see how to implement undo is to
see how Leo's core calls the <tt class="docutils literal"><span class="pre">u.beforeX</span></tt> and <tt class="docutils literal"><span class="pre">afterX</span></tt> methods.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id9" id="turning-script-buttons-into-plugins" name="turning-script-buttons-into-plugins">Turning script buttons into plugins</a></h2>
<p>This section provides step-by-step instructions for turning a script button into a plugin.
The plugin will define a minibuffer command that does the same thing as pressing the button.</p>
<p>We shall start with a script button whose script is:</p>
<pre class="literal-block">
g.es_print('c: %s' % (c.fileName()),color='red')
g.es_print('p: %s' % (p.headString()),color='red')
</pre>
<p>Not very exciting, but it uses the predefined <tt class="docutils literal"><span class="pre">c</span></tt> and <tt class="docutils literal"><span class="pre">p</span></tt> constants.
Our plugin will create a minibuffer command called print-cp.</p>
<p>Here are the step-by-step instructions:</p>
<ol class="arabic simple">
<li>Open leoPlugins.leo and use the Copy Node command to copy the tree at:</li>
</ol>
<p>Plugins--&gt; Templates: these show recommended ways of defining plugins.--&gt;Template for Tk plugin with per-commander controller class</p>
<ol class="arabic" start="2">
<li><p class="first">Paste the tree somewhere else and rename it to &#64;thin print_cp.py.
I copied the tree to:</p>
<pre class="literal-block">
Plugins--&gt;Example code--&gt;&#64;thin print_cp.py
</pre>
</li>
<li><p class="first">Update the docstring, the __version__ constant and the &lt;&lt; imports &gt;&gt; section.
Note that unlike when using script buttons, you must have the following imports:</p>
<pre class="literal-block">
import leoGlobals as g
import leoPlugins
</pre>
</li>
<li><p class="first">Because this plugin doesn't require any gui interface, we simplify the <tt class="docutils literal"><span class="pre">init</span></tt> function:</p>
<pre class="literal-block">
def init ():
    leoPlugins.registerHandler('after-create-leo-frame',onCreate)
    return True
</pre>
<p>The init function registers the onCreate hook and
returns True to indicate that it loaded properly.</p>
</li>
<li><p class="first">Leave the <tt class="docutils literal"><span class="pre">onCreate</span></tt> function unchanged.
It creates a per-commander instance of the pluginController class.
This class exists mainly to bind self.c properly to a commander.</p>
</li>
<li><p class="first">Change the constructor (__init__ method) of the pluginController class to this:</p>
<pre class="literal-block">
def __init__ (self,c):
    self.c = c
    c.k.registerCommand('print-cp',shortcut=None,func=self.print_cp)
    script = &quot;c.k.simulateCommand('print-cp')&quot;
    g.makeScriptButton(c,script=script,buttonText='Print c &amp; p',bg='red')
</pre>
<p>This registers the print_cp <em>method</em> of the print_cp class as the print-cp minibuffer command,
and creates a script button with the following script:</p>
<pre class="literal-block">
c.k.simulateCommand('print-cp')
</pre>
</li>
<li><p class="first">Define the print_cp method as follows:</p>
<pre class="literal-block">
def print_cp (self,event=None):
    c = self.c ; p = c.currentPosition()
    g.es_print('c: %s' % (c.fileName()),color='red')
    g.es_print('p: %s' % (p.headString()),color='red')
</pre>
<p>The print_cp method must have the event argument as shown because it implements a minibuffer command.
The print_cp method gets the proper commander from the <tt class="docutils literal"><span class="pre">c</span></tt> ivar (instance variable) and computes
the current position <tt class="docutils literal"><span class="pre">p</span></tt> as shown.</p>
</li>
<li><p class="first">Enable the print_cp plugin using the plugins manager plugin,
or just add the following line somewhere in pluginsManager.txt:</p>
<pre class="literal-block">
print_cp.py
</pre>
</li>
<li><p class="first">Test the plugin by restarting Leo (I just start test.leo).
You can test the plugin by pressing the 'Print c&amp;p' button
or by typing &lt;Alt-x&gt; print-cp &lt;Return&gt;.</p>
</li>
</ol>
<p>That's all.  You can find the completed version of the print_cp plugin in leoPlugins.leo,
or leoPluginsRef.leo if you are using cvs.</p>
<hr class="docutils" />
<p><a class="reference" href="plugins.html"><img alt="back" src="arrow_lt.gif" /></a> <a class="reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference" href="rstplugin3.html"><img alt="next" src="arrow_rt.gif" /></a></p>
</div>
</div>
</div>
</body>
</html>
