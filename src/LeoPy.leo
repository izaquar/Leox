<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.636103151862">
	<global_window_position top="122" left="393" height="773" width="1536"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="AGP.20240903164001"><vh>@version ../VERSION</vh></v>
<v t="ekr.20031218072017.2406" a="ETV"><vh>Code</vh>
<v t="ekr.20031218072017.2604"><vh>Core classes...</vh>
<v t="ekr.20031218072017.2605" a="E"><vh>@thin leo.py </vh></v>
<v t="ekr.20031218072017.2608"
marks="ekr.20031218072017.2610,"><vh>@thin leoApp.py</vh></v>
<v t="ekr.20041005105605.1"
marks="ekr.20041005105605.52,ekr.20041005105605.198,"><vh>@thin leoAtFile.py</vh></v>
<v t="ekr.20031218072017.1602"><vh>&lt;&lt; initialize ivars &amp; tags &gt;&gt; colorizeAnyLanguage</vh>
<v t="ekr.20060829084924"><vh>&lt;&lt; configure fonts &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1603" a="M"><vh>&lt;&lt; configure tags &gt;&gt;</vh></v>
<v t="ekr.20031218072017.370"><vh>&lt;&lt; configure language-specific settings &gt;&gt; colorizer</vh></v>
</v>
<v t="ekr.20031218072017.2794"
marks="ekr.20031218072017.1607,AGP.20240323143050,AGP.20240323150504.2,ekr.20031218072017.1896,ekr.20031218072017.2803,"><vh>@thin leoColor.py</vh></v>
<v t="ekr.20031218072017.2810" a="E"
marks="ekr.20040629121554.2,AGP.20231026214426,AGP.20231026221751,AGP.20231124105345,"
expanded="ekr.20041118104831,ekr.20031218072017.2811,ekr.20031218072017.2582,ekr.20031218072017.2818,ekr.20031218072017.2819,ekr.20031218072017.2820,ekr.20031218072017.2861,ekr.20031218072017.2862,ekr.20031218072017.2864,ekr.20031218072017.1831,ekr.20031218072017.2949,ekr.20060906211747,ekr.20060906211747.1,"><vh>@thin leoCommands.py</vh></v>
<v t="ekr.20041117062700"
marks="ekr.20060608221203,ekr.20041120064303,"><vh>@thin leoConfig.py</vh></v>
<v t="ekr.20050710142719" a="E"
marks="ekr.20050920084036.138,ekr.20051020120306.6,ekr.20050920084036.257,ekr.20050920084036.259,ekr.20051022212004,"
expanded="ekr.20050920084036.186,ekr.20050920084036.188,"><vh>@thin leoEditCommands.py</vh></v>
<v t="ekr.20031218072017.3018" a="E"
marks="ekr.20060919110638.44,ekr.20031218072017.1553,ekr.20031218072017.2306,ekr.20031218072017.1561,ekr.20040701065235.2,"
expanded="ekr.20031218072017.3032,"><vh>@thin leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3093"
marks="AGP.20240831132732,AGP.20240831144820,AGP.20240311094204,AGP.20240823184728.1,AGP.20240311094204.10,ekr.20031218072017.3132,ekr.20031218072017.3124,ekr.20031218072017.2278,"><vh>@thin leoGlobals.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@thin leoImport.py</vh></v>
<v t="ekr.20031218072017.3748"
marks="ekr.20051126124705,ekr.20060216163305,ekr.20060120200818,ekr.20060606095344,"><vh>@thin leoKeys.py</vh></v>
<v t="ekr.20031218072017.3320" a="E"
marks="ekr.20031218072017.1485,ekr.20031218072017.3419,ekr.20031218072017.3421,ekr.20031218072017.3426,ekr.20031218072017.3438,ekr.20031218072017.892,ekr.20040303214038,ekr.20040303163330,ekr.20040303175026.3,ekr.20040303175026.5,ekr.20040303175026.10,ekr.20040306060312,ekr.20040303175026.11,ekr.20040310062332.4,ekr.20040310062332.5,"
expanded="ekr.20031218072017.3321,ekr.20031218072017.3331,ekr.20031218072017.1484,"><vh>@thin leoNodes.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@thin leoPlugins.py</vh></v>
<v t="ekr.20061024060248.1"><vh>thin leoPymacs.py</vh>
<v t="ekr.20061024060248.2"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20061024131236"><vh>dump</vh></v>
<v t="ekr.20061024130957"><vh>getters</vh></v>
<v t="ekr.20061024060248.3"><vh>hello</vh></v>
<v t="ekr.20061024075542"><vh>init</vh></v>
<v t="ekr.20061024075542.1"><vh>open</vh></v>
<v t="ekr.20061024084200"><vh>run-script</vh></v>
</v>
<v t="ekr.20031218072017.3446"
marks="ekr.20031218072017.3601,"><vh>@thin leoTangle.py</vh></v>
<v t="ekr.20051104075904" annotate="285808000000616e6e6f7461746571007d71017471022e"><vh>@thin leoTest.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@thin leoUndo.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui Base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3630"><vh>thin leoCompare.py</vh>
<v t="ekr.20031218072017.3631"><vh>choose</vh></v>
<v t="ekr.20031218072017.3632"><vh>go</vh></v>
<v t="ekr.20031218072017.3633"><vh>class leoCompare</vh>
<v t="ekr.20031218072017.3634"><vh>compare.__init__</vh></v>
<v t="ekr.20031218072017.3635"><vh>compare_directories (entry)</vh></v>
<v t="ekr.20031218072017.3636"><vh>compare_files (entry)</vh></v>
<v t="ekr.20031218072017.3637"><vh>compare_lines</vh></v>
<v t="ekr.20031218072017.3638"><vh>compare_open_files</vh>
<v t="ekr.20031218072017.3639"><vh>&lt;&lt; handle opening lines &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3640"><vh>&lt;&lt; ignore blank lines and/or sentinels &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3641"><vh>&lt;&lt; print matches and/or mismatches &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3642"><vh>&lt;&lt; warn if mismatch limit reached &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3643"><vh>&lt;&lt; handle reporting after at least one eof is seen &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3644"><vh>filecmp</vh></v>
<v t="ekr.20031218072017.3645"><vh>utils...</vh>
<v t="ekr.20031218072017.3646"><vh>doOpen</vh></v>
<v t="ekr.20031218072017.3647"><vh>dump</vh></v>
<v t="ekr.20031218072017.3648"><vh>dumpToEndOfFile</vh></v>
<v t="ekr.20031218072017.3649"><vh>isLeoHeader &amp; isSentinel</vh></v>
<v t="ekr.20031218072017.1144"><vh>openOutputFile (compare)</vh></v>
<v t="ekr.20031218072017.3650"><vh>show</vh></v>
<v t="ekr.20031218072017.3651"><vh>showIvars</vh></v>
</v>
</v>
</v>
<v t="ekr.20060123151617"
marks="ekr.20051113110851,ekr.20031218072017.3074,ekr.20031218072017.3077,ekr.20031218072017.3081,"><vh>@thin leoFind.py</vh></v>
<v t="ekr.20031218072017.3655" a="E"
expanded="ekr.20031218072017.3678,ekr.20031218072017.3680,ekr.20031218072017.3704,ekr.20031218072017.3706,ekr.20031218072017.2233,ekr.20031218072017.2236,"><vh>@thin leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@thin leoGui.py</vh></v>
<v t="ekr.20031218072017.3749"
marks="ekr.20031218072017.3785,ekr.20050921103736,ekr.20031218072017.3803,ekr.20031218072017.3804,"><vh>@thin leoMenu.py</vh></v>
</v>
<v t="ekr.20031218072017.3821"><vh>Gui Tkinter classes</vh>
<v t="ekr.20031218072017.4099"><vh>thin leoTkinterKeys.py</vh></v>
<v t="ekr.20031218072017.3838"><vh>thin leoTkinterComparePanel.py</vh>
<v t="ekr.20031218072017.3839"><vh>Birth...</vh>
<v t="ekr.20031218072017.3840"><vh> tkinterComparePanel.__init__</vh>
<v t="ekr.20031218072017.3841"><vh>&lt;&lt; init tkinter compare ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3842"><vh>finishCreate (tkComparePanel)</vh></v>
<v t="ekr.20031218072017.3843"><vh>createFrame (tkComparePanel)</vh>
<v t="ekr.20031218072017.3844"><vh>&lt;&lt; create the organizer frames &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3845"><vh>&lt;&lt; create the browser rows &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3846"><vh>&lt;&lt; create the extension row &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3847"><vh>&lt;&lt; create the whitespace options frame &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3848"><vh>&lt;&lt; create the print options frame &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3849"><vh>&lt;&lt; create the compare buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3850"><vh>setIvarsFromWidgets</vh></v>
</v>
<v t="ekr.20031218072017.3851"><vh>bringToFront</vh></v>
<v t="ekr.20031218072017.3852"><vh>browser</vh></v>
<v t="ekr.20031218072017.3853"><vh>Event handlers...</vh>
<v t="ekr.20031218072017.3854"><vh>onBrowse...</vh></v>
<v t="ekr.20031218072017.3855"><vh>onClose</vh></v>
<v t="ekr.20031218072017.3856"><vh>onCompare...</vh></v>
<v t="ekr.20031218072017.3857"><vh>onPrintMatchedLines</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3897"><vh>thin leoTkinterFind.py</vh>
<v t="ekr.20041025152343"><vh>class underlinedTkButton</vh>
<v t="ekr.20041025152712"><vh>__init__</vh>
<v t="ekr.20041025152712.2"><vh>&lt;&lt; set self.hotKey if '&amp;' is in the string &gt;&gt;</vh></v>
</v>
<v t="ekr.20041026080125"><vh>bindHotKey</vh></v>
<v t="ekr.20041025152717"><vh>buttonCallback</vh></v>
</v>
<v t="ekr.20041025152343.1"><vh>class leoTkinterFind</vh>
<v t="ekr.20031218072017.3898"><vh>Birth &amp; death</vh>
<v t="ekr.20031218072017.3899"><vh>__init__</vh>
<v t="ekr.20031218072017.3900"><vh>&lt;&lt; create the tkinter intVars &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3901"><vh>destroySelf</vh></v>
<v t="ekr.20031218072017.3902"><vh>find.createFrame</vh>
<v t="ekr.20031218072017.3904"><vh>&lt;&lt; Create the Find and Change panes &gt;&gt;</vh>
<v t="ekr.20041026092141"><vh>&lt;&lt; Bind Tab and control-tab &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3903"><vh>&lt;&lt; Create four columns of radio and checkboxes &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3905"><vh>&lt;&lt; Create two rows of buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20060207080537"><vh>find.createBindings</vh></v>
<v t="ekr.20031218072017.2059"><vh>find.init</vh>
<v t="ekr.20031218072017.2060"><vh>&lt;&lt; set find/change widgets &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2061"><vh>&lt;&lt; set radio buttons from ivars &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.1460"><vh>find.update_ivars</vh></v>
<v t="ekr.20050204090259"><vh>tkFind.adjust_find_text</vh></v>
<v t="ekr.20031218072017.3906"><vh>onCloseWindow</vh></v>
<v t="ekr.20051013084256"><vh>dismiss</vh></v>
<v t="ekr.20031218072017.3907"><vh>bringToFront</vh></v>
<v t="EKR.20040603221140"><vh>selectAllFindText</vh></v>
<v t="ekr.20031218072017.3908"><vh>Tkinter wrappers (leoTkinterFind)</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3858"><vh>@thin leoTkinterDialog.py</vh></v>
<v t="ekr.20031218072017.3939"
marks="AGP.20231124085841.5,AGP.20231115182509.1,AGP.20231106120102,ekr.20051009044751,ekr.20051009045208,AGP.20231104061353,ekr.20031218072017.3947,ekr.20041223102225.1,AGP.20231115175745.1,ekr.20031218072017.3968,AGP.20231020155235,AGP.20231020122619,ekr.20041221122440.2,ekr.20041217135735.1,ekr.20051016103459,ekr.20041217135735.2,ekr.20031218072017.4046,EKR.20040423082910,"
expanded="ekr.20031218072017.3940,ekr.20031218072017.3979,ekr.20031218072017.3980,"><vh>@thin leoTkinterFrame.py</vh></v>
<v t="ekr.20031218072017.4047"
marks="AGP.20231109145044,"><vh>@thin leoTkinterGui.py</vh></v>
<v t="ekr.20031218072017.4100"
marks="ekr.20060211144330.1,ekr.20031218072017.4113,ekr.20031218072017.4115,"><vh>@thin leoTkinterMenu.py</vh></v>
<v t="ekr.20040803072955"
marks="ekr.20040803072955.16,ekr.20040803072955.17,AGP.20240318174543.1,ekr.20060131173440,ekr.20040803072955.42,AGP.20231106213403.1,ekr.20040803072955.53,ekr.20040803072955.91,ekr.20040803072955.110,ekr.20040803072955.128,"
expanded="ekr.20040803072955.2,ekr.20040803072955.16,ekr.20040803072955.35,ekr.20040803072955.90,ekr.20040803072955.91,ekr.20040803072955.80,ekr.20040803072955.84,"><vh>@thin leoTkinterTree.py</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="AGP.20240903164001"></t>
<t tx="EKR.20040603221140">def selectAllFindText (self,event=None):

    try:
        w = self.frame.focus_get()
        g.app.gui.setTextSelection(w,"1.0","end")
        return "break"
    except:
        return None # To keep pychecker happy.
</t>
<t tx="ekr.20031218072017.370"># Define has_string, keywords, single_comment_start, block_comment_start, block_comment_end.

if self.language == "cweb": # Use C comments, not cweb sentinel comments.
    delim1,delim2,delim3 = g.set_delims_from_language("c")
elif self.comment_string:
    delim1,delim2,delim3 = g.set_delims_from_string(self.comment_string)
elif self.language == "plain": # 1/30/03
    delim1,delim2,delim3 = None,None,None
else:
    delim1,delim2,delim3 = g.set_delims_from_language(self.language)

self.single_comment_start = delim1
self.block_comment_start = delim2
self.block_comment_end = delim3

# A strong case can be made for making this code as fast as possible.
# Whether this is compatible with general language descriptions remains to be seen.
self.case_sensitiveLanguage = self.language not in case_insensitiveLanguages
self.has_string = self.language != "plain"
if self.language == "plain":
    self.string_delims = ()
elif self.language in ("elisp","html"):
    self.string_delims = ('"')
else:
    self.string_delims = ("'",'"')
self.has_pp_directives = self.language in ("c","csharp","cweb","latex")

# The list of languages for which keywords exist.
# Eventually we might just use language_delims_dict.keys()
languages = [
    "actionscript","ada","c","csharp","css","cweb","elisp","forth","html","java","latex","lua",
    "pascal","perl","perlpod","php","plsql","python","rapidq","rebol","shell","tcltk"]

self.keywords = []
if self.language == "cweb":
    for i in self.c_keywords:
        self.keywords.append(i)
    for i in self.cweb_keywords:
        self.keywords.append(i)
else:
    for name in languages:
        if self.language==name: 
            # g.trace("setting keywords for",name)
            self.keywords = getattr(self, name + "_keywords")

# For forth.
self.nextForthWordIsNew = False

# Color plain text unless we are under the control of @nocolor.
# state = g.choose(self.flag,"normal","nocolor")
state = self.setFirstLineState()

if 1: # 10/25/02: we color both kinds of references in cweb mode.
    self.lb = "&lt;&lt;"
    self.rb = "&gt;&gt;"
else:
    self.lb = g.choose(self.language == "cweb","@&lt;","&lt;&lt;")
    self.rb = g.choose(self.language == "cweb","@&gt;","&gt;&gt;")
</t>
<t tx="ekr.20031218072017.1144">def openOutputFile (self):
    
    if self.outputFileName == None:
        return
    theDir,name = g.os_path_split(self.outputFileName)
    if len(theDir) == 0:
        self.show("empty output directory")
        return
    if len(name) == 0:
        self.show("empty output file name")
        return
    if not g.os_path_exists(theDir):
        self.show("output directory not found: " + theDir)
    else:
        try:
            if self.appendOutput:
                self.show("appending to " + self.outputFileName)
                self.outputFile = open(self.outputFileName,"ab")
            else:
                self.show("writing to " + self.outputFileName)
                self.outputFile = open(self.outputFileName,"wb")
        except:
            self.outputFile = None
            self.show("exception opening output file")
            g.es_exception()
</t>
<t tx="ekr.20031218072017.1460">def update_ivars (self):
    
    """Called just before doing a find to update ivars from the find panel."""

    for key in self.intKeys:
        val = self.dict[key].get()
        setattr(self, key, val) # No more _flag hack.
        # g.trace(key,val)

    # Set ivars from radio buttons. Convert these to 1 or 0.
    if 0: ###
        find_type = self.dict["radio-find-type"].get()
        self.pattern_match = g.choose(find_type == "pattern-search",1,0)
        self.script_search = g.choose(find_type == "script-search",1,0)
    
    search_scope = self.dict["radio-search-scope"].get()
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)
    self.selection       = g.choose(search_scope == "selection-only",1,0) # 11/9/03

    # New in 4.3: The caller is responsible for removing most trailing cruft.
    # Among other things, this allows Leo to search for a single trailing space.
    s = self.find_ctrl.get("1.0","end")
    s = g.toUnicode(s,g.app.tkEncoding)
    # g.trace(repr(s))
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    self.find_text = s

    s = self.change_ctrl.get("1.0","end")
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    s = g.toUnicode(s,g.app.tkEncoding)
    self.change_text = s
</t>
<t tx="ekr.20031218072017.1602"># Add any newly-added user keywords.
for d in g.globalDirectiveList:
    name = '@' + d
    if name not in leoKeywords:
        leoKeywords.append(name)

# Copy the arguments.
self.p = p

# Get the body text, converted to unicode.
s = self.body.getAllText() # 10/27/03
self.sel = sel = self.body.getInsertionPoint() # 10/27/03
start,end = self.body.convertIndexToRowColumn(sel) # 10/27/03

if self.language: self.language = self.language.lower() # 6/20/05
# g.trace(self.count,self.p)
# g.trace(body.tag_names())

if not self.incremental:
    self.removeAllTags()
    self.removeAllImages()

self.redoColoring = False
self.redoingColoring = False

&lt;&lt; configure fonts &gt;&gt;
&lt;&lt; configure tags &gt;&gt;
&lt;&lt; configure language-specific settings &gt;&gt;

self.hyperCount = 0 # Number of hypertext tags
self.count += 1
lines = string.split(s,'\n')
</t>
<t tx="ekr.20031218072017.1603"># g.trace('configure tags',self.body.bodyCtrl)
# agp color

#print 'configurertags2'

for name in default_colors_dict.keys(): # Python 2.1 support.
    option_name,default_color = default_colors_dict[name]
    #option_color = c.config.getColor(option_name)
    #color = g.choose(option_color,option_color,default_color)
    # Must use foreground, not fg.
    try:
        self.body.tag_configure(name, foreground=default_color)
    except: # Recover after a user error.
        self.body.tag_configure(name, foreground=default_color)



underline_undefined = c.config.getBool("underline_undefined_section_names")
use_hyperlinks      = c.config.getBool("use_hyperlinks")
self.use_hyperlinks = use_hyperlinks

# underline=var doesn't seem to work.
if 0: # use_hyperlinks: # Use the same coloring, even when hyperlinks are in effect.
    self.body.tag_configure("link",underline=1) # defined
    self.body.tag_configure("name",underline=0) # undefined
else:
    self.body.tag_configure("link",underline=0)
    if underline_undefined:
        self.body.tag_configure("name",underline=1)
    else:
        self.body.tag_configure("name",underline=0)
        
# 8/4/02: we only create tags for whitespace when showing invisibles.
if self.showInvisibles:
    for name,option_name,default_color in (
        ("blank","show_invisibles_space_background_color","Gray90"),
        ("tab",  "show_invisibles_tab_background_color",  "Gray80")):
        option_color = c.config.getColor(option_name)
        color = g.choose(option_color,option_color,default_color)
        try:
            self.body.tag_configure(name,background=color)
        except: # Recover after a user error.
            self.body.tag_configure(name,background=default_color)
    
# 11/15/02: Colors for latex characters.  Should be user options...

if 1: # Alas, the selection doesn't show if a background color is specified.
    self.body.tag_configure("latexModeBackground",foreground="black")
    self.body.tag_configure("latexModeKeyword",foreground="blue")
    self.body.tag_configure("latexBackground",foreground="black")
    self.body.tag_configure("latexKeyword",foreground="blue")
else: # Looks cool, and good for debugging.
    self.body.tag_configure("latexModeBackground",foreground="black",background="seashell1")
    self.body.tag_configure("latexModeKeyword",foreground="blue",background="seashell1")
    self.body.tag_configure("latexBackground",foreground="black",background="white")
    self.body.tag_configure("latexKeyword",foreground="blue",background="white")
    
# Tags for wiki coloring.
if self.showInvisibles:
    self.body.tag_configure("elide",background="yellow")
else:
    self.body.tag_configure("elide",elide="1")
self.body.tag_configure("bold",font=self.bold_font)
self.body.tag_configure("italic",font=self.italic_font)
self.body.tag_configure("bolditalic",font=self.bolditalic_font)
for name in self.color_tags_list:
    self.body.tag_configure(name,foreground=name)
</t>
<t tx="ekr.20031218072017.2059">def init (self,c):

    # N.B.: separate c.ivars are much more convenient than a dict.
    for key in self.intKeys:
        # New in 4.3: get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0) # Work around major Tk problem.
        self.dict[key].set(val)
        # g.trace(key,val)

    &lt;&lt; set find/change widgets &gt;&gt;
    &lt;&lt; set radio buttons from ivars &gt;&gt;
</t>
<t tx="ekr.20031218072017.2060">self.find_ctrl.delete("1.0","end")
self.change_ctrl.delete("1.0","end")

# New in 4.3: Get setting from @settings.
for w,setting,defaultText in (
    (self.find_ctrl,"find_text",'&lt;find pattern here&gt;'),
    (self.change_ctrl,"change_text",''),
):
    s = c.config.getString(setting)
    if not s: s = defaultText
    w.insert("end",s)
</t>
<t tx="ekr.20031218072017.2061">found = False
for var,setting in (
    ("pattern_match","pattern-search"),
    ("script_search","script-search")):
    val = self.dict[var].get()
    if val:
        self.dict["radio-find-type"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-find-type"].set("plain-search")
    
found = False
for var,setting in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    # ("selection_only","selection-only"),
):
    val = self.dict[var].get()
    if val:
        self.dict["radio-search-scope"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-search-scope"].set("entire-outline")
</t>
<t tx="ekr.20031218072017.2406">@tabwidth -4
@pagewidth 80

@ This section contains all the source code of leo.py.

Leo's code uses the following conventions throughout:

c:  a commander
ch: a character
d:  a dialog or a dict.
g:  the leoGlobal module.
i, j, k: indices into a string
p:  a position.
s:  a string
t:  a tnode or a text widget.
u:  an undoer
v:  a vnode
z:  a local temp.</t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;
</t>
<t tx="ekr.20031218072017.3630">@language python
@tabwidth -4
@pagewidth 80

"""Leo's base compare class."""

import leoGlobals as g
import filecmp
import os
import string

@others
</t>
<t tx="ekr.20031218072017.3631">def choose(cond, a, b): # warning: evaluates all arguments

    if cond: return a
    else: return b
</t>
<t tx="ekr.20031218072017.3632">def go ():

    compare = leoCompare(
        commands = None,
        
        appendOutput = True,

        ignoreBlankLines = True,
        ignoreFirstLine1 = False,
        ignoreFirstLine2 = False,
        ignoreInteriorWhitespace = False,
        ignoreLeadingWhitespace = True,
        ignoreSentinelLines = False,
        
        limitCount = 9, # Zero means don't stop.
        limitToExtension = ".py",  # For directory compares.
        makeWhitespaceVisible = True,
        
        printBothMatches = False,
        printMatches = False,
        printMismatches = True,
        printTrailingMismatches = False,

        outputFileName = None)

    if 1: # Compare all files in Tangle test directories

        path1 = "c:\\prog\\test\\tangleTest\\"
        path2 = "c:\\prog\\test\\tangleTestCB\\"
        compare.compare_directories(path1,path2)

    else: # Compare two files.

        name1 = "c:\\prog\\test\\compare1.txt"
        name2 = "c:\\prog\\test\\compare2.txt"
        compare.compare_files(name1,name2)
</t>
<t tx="ekr.20031218072017.3633">class baseLeoCompare:
    """The base class for Leo's compare code."""
    @others
    
class leoCompare (baseLeoCompare):
    """A class containing Leo's compare code."""
    pass
</t>
<t tx="ekr.20031218072017.3634"># All these ivars are known to the leoComparePanel class.

def __init__ (self,

    # Keyword arguments are much convenient and more clear for scripts.
    commands = None,
    
    appendOutput = False,

    ignoreBlankLines = True,
    ignoreFirstLine1 = False,
    ignoreFirstLine2 = False,
    ignoreInteriorWhitespace = False,
    ignoreLeadingWhitespace = True,
    ignoreSentinelLines = False,

    limitCount = 0, # Zero means don't stop.
    limitToExtension = ".py",  # For directory compares.
    makeWhitespaceVisible = True,

    printBothMatches = False,
    printMatches = False,
    printMismatches = True,
    printTrailingMismatches = False,

    outputFileName = None ):
        
    __pychecker__ = 'maxargs=50'
        
    # It is more convenient for the leoComparePanel to set these directly.
    self.c = commands
    
    self.appendOutput = appendOutput

    self.ignoreBlankLines = ignoreBlankLines
    self.ignoreFirstLine1 = ignoreFirstLine1
    self.ignoreFirstLine2 = ignoreFirstLine2
    self.ignoreInteriorWhitespace = ignoreInteriorWhitespace
    self.ignoreLeadingWhitespace = ignoreLeadingWhitespace
    self.ignoreSentinelLines = ignoreSentinelLines

    self.limitCount = limitCount
    self.limitToExtension = limitToExtension
    
    self.makeWhitespaceVisible = makeWhitespaceVisible

    self.printBothMatches = printBothMatches
    self.printMatches = printMatches
    self.printMismatches = printMismatches
    self.printTrailingMismatches = printTrailingMismatches
    
    # For communication between methods...
    self.outputFileName = outputFileName
    self.fileName1 = None 
    self.fileName2 = None
    # Open files...
    self.outputFile = None
</t>
<t tx="ekr.20031218072017.3635"># We ignore the filename portion of path1 and path2 if it exists.

def compare_directories (self,path1,path2):
    
    # Ignore everything except the directory name.
    dir1 = g.os_path_dirname(path1)
    dir2 = g.os_path_dirname(path2)
    dir1 = g.os_path_normpath(dir1)
    dir2 = g.os_path_normpath(dir2)
    
    if dir1 == dir2:
        return self.show("Please pick distinct directories.")
    try:
        list1 = os.listdir(dir1)
    except:
        return self.show("invalid directory:" + dir1)
    try:
        list2 = os.listdir(dir2)
    except:
        return self.show("invalid directory:" + dir2)
        
    if self.outputFileName:
        self.openOutputFile()
    ok = self.outputFileName == None or self.outputFile
    if not ok: return None

    # Create files and files2, the lists of files to be compared.
    files1 = []
    files2 = []
    for f in list1:
        junk, ext = g.os_path_splitext(f)
        if self.limitToExtension:
            if ext == self.limitToExtension:
                files1.append(f)
        else:
            files1.append(f)
    for f in list2:
        junk, ext = g.os_path_splitext(f)
        if self.limitToExtension:
            if ext == self.limitToExtension:
                files2.append(f)
        else:
            files2.append(f)

    # Compare the files and set the yes, no and missing lists.
    yes = [] ; no = [] ; missing1 = [] ; missing2 = []
    for f1 in files1:
        head,f2 = g.os_path_split(f1)
        if f2 in files2:
            try:
                name1 = g.os_path_join(dir1,f1)
                name2 = g.os_path_join(dir2,f2)
                val = filecmp.cmp(name1,name2,0)
                if val: yes.append(f1)
                else:    no.append(f1)
            except:
                self.show("exception in filecmp.cmp")
                g.es_exception()
                missing1.append(f1)
        else:
            missing1.append(f1)
    for f2 in files2:
        head,f1 = g.os_path_split(f2)
        if f1 not in files1:
            missing2.append(f1)
    
    # Print the results.
    for kind, files in (
        ("----- matches --------",yes),
        ("----- mismatches -----",no),
        ("----- not found 1 ------",missing1),
        ("----- not found 2 ------",missing2),
    ):
        self.show(kind)
        for f in files:
            self.show(f)
    
    if self.outputFile:
        self.outputFile.close()
        self.outputFile = None

    return None # To keep pychecker happy.</t>
<t tx="ekr.20031218072017.3636">def compare_files (self, name1, name2):
    
    if name1 == name2:
        self.show("File names are identical.\nPlease pick distinct files.")
        return

    f1 = f2 = None
    try:
        f1 = self.doOpen(name1)
        f2 = self.doOpen(name2)
        if self.outputFileName:
            self.openOutputFile()
        ok = self.outputFileName == None or self.outputFile
        ok = g.choose(ok and ok != 0,1,0)
        if f1 and f2 and ok: # Don't compare if there is an error opening the output file.
            self.compare_open_files(f1,f2,name1,name2)
    except:
        self.show("exception comparing files")
        g.es_exception()
    try:
        if f1: f1.close()
        if f2: f2.close()
        if self.outputFile:
            self.outputFile.close() ; self.outputFile = None
    except:
        self.show("exception closing files")
        g.es_exception()
</t>
<t tx="ekr.20031218072017.3637">def compare_lines (self,s1,s2):
    
    if self.ignoreLeadingWhitespace:
        s1 = s1.lstrip()
        s2 = s2.lstrip()

    if self.ignoreInteriorWhitespace:
        k1 = g.skip_ws(s1,0)
        k2 = g.skip_ws(s2,0)
        ws1 = s1[:k1]
        ws2 = s2[:k2]
        tail1 = s1[k1:]
        tail2 = s2[k2:]
        tail1 = string.replace(tail1," ","")
        tail1 = string.replace(tail1,"\t","")
        tail2 = string.replace(tail2," ","")
        tail2 = string.replace(tail2,"\t","")
        s1 = ws1 + tail1
        s2 = ws2 + tail2

    return s1 == s2
</t>
<t tx="ekr.20031218072017.3638">def compare_open_files (self, f1, f2, name1, name2):

    # self.show("compare_open_files")
    lines1 = 0 ; lines2 = 0 ; mismatches = 0 ; printTrailing = True
    sentinelComment1 = sentinelComment2 = None
    if self.openOutputFile():
        self.show("1: " + name1)
        self.show("2: " + name2)
        self.show("")
    s1 = s2 = None
    &lt;&lt; handle opening lines &gt;&gt;
    while 1:
        if s1 == None:
            s1 = g.readlineForceUnixNewline(f1) ; lines1 += 1
        if s2 == None:
            s2 = g.readlineForceUnixNewline(f2) ; lines2 += 1
        &lt;&lt; ignore blank lines and/or sentinels &gt;&gt;
        n1 = len(s1) ; n2 = len(s2)
        if n1==0 and n2 != 0: self.show("1.eof***:")
        if n2==0 and n1 != 0: self.show("2.eof***:")
        if n1==0 or n2==0: break
        match = self.compare_lines(s1,s2)
        if not match: mismatches += 1
        &lt;&lt; print matches and/or mismatches &gt;&gt;
        &lt;&lt; warn if mismatch limit reached &gt;&gt;
        s1 = s2 = None # force a read of both lines.
    &lt;&lt; handle reporting after at least one eof is seen &gt;&gt;
</t>
<t tx="ekr.20031218072017.3639">if self.ignoreSentinelLines:
    
    s1 = g.readlineForceUnixNewline(f1) ; lines1 += 1
    s2 = g.readlineForceUnixNewline(f2) ; lines2 += 1
    # Note: isLeoHeader may return None.
    sentinelComment1 = self.isLeoHeader(s1)
    sentinelComment2 = self.isLeoHeader(s2)
    if not sentinelComment1: self.show("no @+leo line for " + name1)
    if not sentinelComment2: self.show("no @+leo line for " + name2)
        
if self.ignoreFirstLine1:
    if s1 == None:
        g.readlineForceUnixNewline(f1) ; lines1 += 1
    s1 = None

if self.ignoreFirstLine2:
    if s2 == None:
        g.readlineForceUnixNewline(f2) ; lines2 += 1
    s2 = None
</t>
<t tx="ekr.20031218072017.3640"># Completely empty strings denotes end-of-file.
if s1 and len(s1) &gt; 0:
    if self.ignoreBlankLines and len(string.strip(s1)) == 0:
        s1 = None ; continue
        
    if self.ignoreSentinelLines and sentinelComment1 and self.isSentinel(s1,sentinelComment1):
        s1 = None ; continue

if s2 and len(s2) &gt; 0:
    if self.ignoreBlankLines and len(string.strip(s2)) == 0:
        s2 = None ; continue

    if self.ignoreSentinelLines and sentinelComment2 and self.isSentinel(s2,sentinelComment2):
        s2 = None ; continue
</t>
<t tx="ekr.20031218072017.3641">if self.limitCount == 0 or mismatches &lt;= self.limitCount:

    if match and self.printMatches:
        
        if self.printBothMatches:
            self.dump(string.rjust("1." + str(lines1),6) + ' :',s1)
            self.dump(string.rjust("2." + str(lines2),6) + ' :',s2)
        else:
            self.dump(string.rjust(       str(lines1),6) + ' :',s1)
    
    if not match and self.printMismatches:
        
        self.dump(string.rjust("1." + str(lines1),6) + '*:',s1)
        self.dump(string.rjust("2." + str(lines2),6) + '*:',s2)
</t>
<t tx="ekr.20031218072017.3642">if self.limitCount &gt; 0 and mismatches &gt;= self.limitCount:
    
    if printTrailing:
        self.show("")
        self.show("limit count reached")
        self.show("")
        printTrailing = False
</t>
<t tx="ekr.20031218072017.3643">if n1 &gt; 0: 
    lines1 += self.dumpToEndOfFile("1.",f1,s1,lines1,printTrailing)
    
if n2 &gt; 0:
    lines2 += self.dumpToEndOfFile("2.",f2,s2,lines2,printTrailing)

self.show("")
self.show("lines1:" + str(lines1))
self.show("lines2:" + str(lines2))
self.show("mismatches:" + str(mismatches))
</t>
<t tx="ekr.20031218072017.3644">def filecmp (self,f1,f2):

    val = filecmp.cmp(f1,f2)
    if 1:
        if val: self.show("equal")
        else:   self.show("*** not equal")
    else:
        self.show("filecmp.cmp returns:")
        if val: self.show(str(val)+ " (equal)")
        else:   self.show(str(val) + " (not equal)")
    return val
</t>
<t tx="ekr.20031218072017.3645"></t>
<t tx="ekr.20031218072017.3646">def doOpen (self,name):

    try:
        f = open(name,'r')
        return f
    except:
        self.show("can not open:" + '"' + name + '"')
        return None
</t>
<t tx="ekr.20031218072017.3647">def dump (self,tag,s):

    compare = self ; out = tag

    for ch in s[:-1]: # don't print the newline
    
        if compare.makeWhitespaceVisible:
            if ch == '\t':
                out += "[" ; out += "t" ; out += "]"
            elif ch == ' ':
                out += "[" ; out += " " ; out += "]"
            else: out += ch
        else:
            if 1:
                out += ch
            else: # I don't know why I thought this was a good idea ;-)
                if ch == '\t' or ch == ' ':
                    out += ' '
                else:
                    out += ch

    self.show(out)
</t>
<t tx="ekr.20031218072017.3648">def dumpToEndOfFile (self,tag,f,s,line,printTrailing):

    trailingLines = 0
    while 1:
        if not s:
            s = g.readlineForceUnixNewline(f)
        if len(s) == 0: break
        trailingLines += 1
        if self.printTrailingMismatches and printTrailing:
            tag2 = string.rjust(tag + str(line),6) + "+:"
            self.dump(tag2,s)
        s = None

    self.show(tag + str(trailingLines) + " trailing lines")
    return trailingLines
</t>
<t tx="ekr.20031218072017.3649">@ These methods are based on atFile.scanHeader().  They are simpler because we only care about the starting sentinel comment: any line starting with the starting sentinel comment is presumed to be a sentinel line.
@c

def isLeoHeader (self,s):

    tag = "@+leo"
    j = string.find(s,tag)
    if j &gt; 0:
        i = g.skip_ws(s,0)
        if i &lt; j: return s[i:j]
        else: return None
    else: return None
        
def isSentinel (self,s,sentinelComment):

    i = g.skip_ws(s,0)
    return g.match(s,i,sentinelComment)
</t>
<t tx="ekr.20031218072017.3650">def show (self,s):
    
    # print s
    if self.outputFile:
        self.outputFile.write(s + '\n')
    elif self.c:
        g.es(s)
    else:
        print s
        print
</t>
<t tx="ekr.20031218072017.3651">def showIvars (self):
    
    self.show("fileName1:"        + str(self.fileName1))
    self.show("fileName2:"        + str(self.fileName2))
    self.show("outputFileName:"   + str(self.outputFileName))
    self.show("limitToExtension:" + str(self.limitToExtension))
    self.show("")

    self.show("ignoreBlankLines:"         + str(self.ignoreBlankLines))
    self.show("ignoreFirstLine1:"         + str(self.ignoreFirstLine1))
    self.show("ignoreFirstLine2:"         + str(self.ignoreFirstLine2))
    self.show("ignoreInteriorWhitespace:" + str(self.ignoreInteriorWhitespace))
    self.show("ignoreLeadingWhitespace:"  + str(self.ignoreLeadingWhitespace))
    self.show("ignoreSentinelLines:"      + str(self.ignoreSentinelLines))
    self.show("")
    
    self.show("limitCount:"              + str(self.limitCount))
    self.show("printMatches:"            + str(self.printMatches))
    self.show("printMismatches:"         + str(self.printMismatches))
    self.show("printTrailingMismatches:" + str(self.printTrailingMismatches))
</t>
<t tx="ekr.20031218072017.3821"></t>
<t tx="ekr.20031218072017.3838">"""Leo's base compare class."""

@language python
@tabwidth -4
@pagewidth 80

import leoGlobals as g
import leoCompare
import leoTkinterDialog
import Tkinter as Tk
import tkFileDialog

class leoTkinterComparePanel (leoCompare.leoCompare,leoTkinterDialog.leoTkinterDialog):
    
    """A class that creates Leo's compare panel."""

    @others
</t>
<t tx="ekr.20031218072017.3839"></t>
<t tx="ekr.20031218072017.3840">def __init__ (self,c):
    
    # Init the base class.
    leoCompare.leoCompare.__init__ (self,c)
    leoTkinterDialog.leoTkinterDialog.__init__(self,c,"Compare files and directories",resizeable=False)

    if g.app.unitTesting: return

    self.c = c

    &lt;&lt; init tkinter compare ivars &gt;&gt;
    
    # These ivars are set from Entry widgets.
    self.limitCount = 0
    self.limitToExtension = None
    
    # The default file name in the "output file name" browsers.
    self.defaultOutputFileName = "CompareResults.txt"
    
    self.createTopFrame()
    self.createFrame()
</t>
<t tx="ekr.20031218072017.3841"># Ivars pointing to Tk elements.
self.browseEntries = []
self.extensionEntry = None
self.countEntry = None
self.printButtons = []
    
# No corresponding ivar in the leoCompare class.
self.useOutputFileVar = Tk.IntVar()

# These all correspond to ivars in leoCompare
self.appendOutputVar             = Tk.IntVar()

self.ignoreBlankLinesVar         = Tk.IntVar()
self.ignoreFirstLine1Var         = Tk.IntVar()
self.ignoreFirstLine2Var         = Tk.IntVar()
self.ignoreInteriorWhitespaceVar = Tk.IntVar()
self.ignoreLeadingWhitespaceVar  = Tk.IntVar()
self.ignoreSentinelLinesVar      = Tk.IntVar()

self.limitToExtensionVar         = Tk.IntVar()
self.makeWhitespaceVisibleVar    = Tk.IntVar()

self.printBothMatchesVar         = Tk.IntVar()
self.printMatchesVar             = Tk.IntVar()
self.printMismatchesVar          = Tk.IntVar()
self.printTrailingMismatchesVar  = Tk.IntVar()
self.stopAfterMismatchVar        = Tk.IntVar()
</t>
<t tx="ekr.20031218072017.3842"># Initialize ivars from config parameters.

def finishCreate (self):
    
    c = self.c
    
    # File names.
    for i,option in (
        (0,"compare_file_1"),
        (1,"compare_file_2"),
        (2,"output_file") ):
            
        name = c.config.getString(option)
        if name and len(name) &gt; 0:
            e = self.browseEntries[i]
            e.delete(0,"end")
            e.insert(0,name)
            
    name = c.config.getString("output_file")
    b = g.choose(name and len(name) &gt; 0,1,0)
    self.useOutputFileVar.set(b)

    # File options.
    b = c.config.getBool("ignore_first_line_of_file_1")
    if b == None: b = 0
    self.ignoreFirstLine1Var.set(b)
    
    b = c.config.getBool("ignore_first_line_of_file_2")
    if b == None: b = 0
    self.ignoreFirstLine2Var.set(b)
    
    b = c.config.getBool("append_output_to_output_file")
    if b == None: b = 0
    self.appendOutputVar.set(b)

    ext = c.config.getString("limit_directory_search_extension")
    b = ext and len(ext) &gt; 0
    b = g.choose(b and b != 0,1,0)
    self.limitToExtensionVar.set(b)
    if b:
        e = self.extensionEntry
        e.delete(0,"end")
        e.insert(0,ext)
        
    # Print options.
    b = c.config.getBool("print_both_lines_for_matches")
    if b == None: b = 0
    self.printBothMatchesVar.set(b)
    
    b = c.config.getBool("print_matching_lines")
    if b == None: b = 0
    self.printMatchesVar.set(b)
    
    b = c.config.getBool("print_mismatching_lines")
    if b == None: b = 0
    self.printMismatchesVar.set(b)
    
    b = c.config.getBool("print_trailing_lines")
    if b == None: b = 0
    self.printTrailingMismatchesVar.set(b)
    
    n = c.config.getInt("limit_count")
    b = n and n &gt; 0
    b = g.choose(b and b != 0,1,0)
    self.stopAfterMismatchVar.set(b)
    if b:
        e = self.countEntry
        e.delete(0,"end")
        e.insert(0,str(n))

    # bool options...
    for option,var,default in (
        # Whitespace options.
        ("ignore_blank_lines",self.ignoreBlankLinesVar,1),
        ("ignore_interior_whitespace",self.ignoreInteriorWhitespaceVar,0),
        ("ignore_leading_whitespace",self.ignoreLeadingWhitespaceVar,0),
        ("ignore_sentinel_lines",self.ignoreSentinelLinesVar,0),
        ("make_whitespace_visible", self.makeWhitespaceVisibleVar,0),
    ):
        b = c.config.getBool(option)
        if b is None: b = default
        var.set(b)
    
    if 0: # old code
        b = c.config.getBool("ignore_blank_lines")
        if b == None: b = 1 # unusual default.
        self.ignoreBlankLinesVar.set(b)
        
        b = c.config.getBool("ignore_interior_whitespace")
        if b == None: b = 0
        self.ignoreInteriorWhitespaceVar.set(b)
        
        b = c.config.getBool("ignore_leading_whitespace")
        if b == None: b = 0
        self.ignoreLeadingWhitespaceVar.set(b)
        
        b = c.config.getBool("ignore_sentinel_lines")
        if b == None: b = 0
        self.ignoreSentinelLinesVar.set(b)
        
        b = c.config.getBool("make_whitespace_visible")
        if b == None: b = 0
        self.makeWhitespaceVisibleVar.set(b)
</t>
<t tx="ekr.20031218072017.3843">def createFrame (self):

    gui = g.app.gui ; top = self.top

    &lt;&lt; create the organizer frames &gt;&gt;
    &lt;&lt; create the browser rows &gt;&gt;
    &lt;&lt; create the extension row &gt;&gt;
    &lt;&lt; create the whitespace options frame &gt;&gt;
    &lt;&lt; create the print options frame &gt;&gt;
    &lt;&lt; create the compare buttons &gt;&gt;

    gui.center_dialog(top) # Do this _after_ building the dialog!
    self.finishCreate()
    top.protocol("WM_DELETE_WINDOW", self.onClose)
</t>
<t tx="ekr.20031218072017.3844">outer = Tk.Frame(self.frame, bd=2,relief="groove")
outer.pack(pady=4)

row1 = Tk.Frame(outer)
row1.pack(pady=4)

row2 = Tk.Frame(outer)
row2.pack(pady=4)

row3 = Tk.Frame(outer)
row3.pack(pady=4)

row4 = Tk.Frame(outer)
row4.pack(pady=4,expand=1,fill="x") # for left justification.

options = Tk.Frame(outer)
options.pack(pady=4)

ws = Tk.Frame(options)
ws.pack(side="left",padx=4)

pr = Tk.Frame(options)
pr.pack(side="right",padx=4)

lower = Tk.Frame(outer)
lower.pack(pady=6)
</t>
<t tx="ekr.20031218072017.3845">for row,text,text2,command,var in (
    (row1,"Compare path 1:","Ignore first line",self.onBrowse1,self.ignoreFirstLine1Var),
    (row2,"Compare path 2:","Ignore first line",self.onBrowse2,self.ignoreFirstLine2Var),
    (row3,"Output file:",   "Use output file",  self.onBrowse3,self.useOutputFileVar) ):

    lab = Tk.Label(row,anchor="e",text=text,width=13)
    lab.pack(side="left",padx=4)
    
    e = Tk.Entry(row)
    e.pack(side="left",padx=2)
    self.browseEntries.append(e)
    
    b = Tk.Button(row,text="browse...",command=command)
    b.pack(side="left",padx=6)

    b = Tk.Checkbutton(row,text=text2,anchor="w",variable=var,width=15)
    b.pack(side="left")
</t>
<t tx="ekr.20031218072017.3846">b = Tk.Checkbutton(row4,anchor="w",var=self.limitToExtensionVar,
    text="Limit directory compares to type:")
b.pack(side="left",padx=4)

self.extensionEntry = e = Tk.Entry(row4,width=6)
e.pack(side="left",padx=2)

b = Tk.Checkbutton(row4,anchor="w",var=self.appendOutputVar,
    text="Append output to output file")
b.pack(side="left",padx=4)
</t>
<t tx="ekr.20031218072017.3847">w,f = gui.create_labeled_frame(ws,caption="Whitespace options",relief="groove")
    
for text,var in (
    ("Ignore Leo sentinel lines", self.ignoreSentinelLinesVar),
    ("Ignore blank lines",        self.ignoreBlankLinesVar),
    ("Ignore leading whitespace", self.ignoreLeadingWhitespaceVar),
    ("Ignore interior whitespace",self.ignoreInteriorWhitespaceVar),
    ("Make whitespace visible",   self.makeWhitespaceVisibleVar) ):
    
    b = Tk.Checkbutton(f,text=text,variable=var)
    b.pack(side="top",anchor="w")
    
spacer = Tk.Frame(f)
spacer.pack(padx="1i")
</t>
<t tx="ekr.20031218072017.3848">w,f = gui.create_labeled_frame(pr,caption="Print options",relief="groove")

row = Tk.Frame(f)
row.pack(expand=1,fill="x")

b = Tk.Checkbutton(row,text="Stop after",variable=self.stopAfterMismatchVar)
b.pack(side="left",anchor="w")

self.countEntry = e = Tk.Entry(row,width=4)
e.pack(side="left",padx=2)
e.insert(01,"1")

lab = Tk.Label(row,text="mismatches")
lab.pack(side="left",padx=2)

for padx,text,var in (    
    (0,  "Print matched lines",           self.printMatchesVar),
    (20, "Show both matching lines",      self.printBothMatchesVar),
    (0,  "Print mismatched lines",        self.printMismatchesVar),
    (0,  "Print unmatched trailing lines",self.printTrailingMismatchesVar) ):
    
    b = Tk.Checkbutton(f,text=text,variable=var)
    b.pack(side="top",anchor="w",padx=padx)
    self.printButtons.append(b)
    
# To enable or disable the "Print both matching lines" button.
b = self.printButtons[0]
b.configure(command=self.onPrintMatchedLines)

spacer = Tk.Frame(f)
spacer.pack(padx="1i")
</t>
<t tx="ekr.20031218072017.3849">for text,command in (
    ("Compare files",      self.onCompareFiles),
    ("Compare directories",self.onCompareDirectories) ):
    
    b = Tk.Button(lower,text=text,command=command,width=18)
    b.pack(side="left",padx=6)
</t>
<t tx="ekr.20031218072017.3850">def setIvarsFromWidgets (self):

    # File paths: checks for valid file name.
    e = self.browseEntries[0]
    self.fileName1 = e.get()
    
    e = self.browseEntries[1]
    self.fileName2 = e.get()

    # Ignore first line settings.
    self.ignoreFirstLine1 = self.ignoreFirstLine1Var.get()
    self.ignoreFirstLine2 = self.ignoreFirstLine2Var.get()
    
    # Output file: checks for valid file name.
    if self.useOutputFileVar.get():
        e = self.browseEntries[2]
        name = e.get()
        if name != None and len(name) == 0:
            name = None
        self.outputFileName = name
    else:
        self.outputFileName = None

    # Extension settings.
    if self.limitToExtensionVar.get():
        self.limitToExtension = self.extensionEntry.get()
        if len(self.limitToExtension) == 0:
            self.limitToExtension = None
    else:
        self.limitToExtension = None
        
    self.appendOutput = self.appendOutputVar.get()
    
    # Whitespace options.
    self.ignoreBlankLines         = self.ignoreBlankLinesVar.get()
    self.ignoreInteriorWhitespace = self.ignoreInteriorWhitespaceVar.get()
    self.ignoreLeadingWhitespace  = self.ignoreLeadingWhitespaceVar.get()
    self.ignoreSentinelLines      = self.ignoreSentinelLinesVar.get()
    self.makeWhitespaceVisible    = self.makeWhitespaceVisibleVar.get()
    
    # Print options.
    self.printMatches            = self.printMatchesVar.get()
    self.printMismatches         = self.printMismatchesVar.get()
    self.printTrailingMismatches = self.printTrailingMismatchesVar.get()
    
    if self.printMatches:
        self.printBothMatches = self.printBothMatchesVar.get()
    else:
        self.printBothMatches = False
    
    if self.stopAfterMismatchVar.get():
        try:
            count = self.countEntry.get()
            self.limitCount = int(count)
        except: self.limitCount = 0
    else:
        self.limitCount = 0
</t>
<t tx="ekr.20031218072017.3851">def bringToFront(self):
    
    self.top.deiconify()
    self.top.lift()
</t>
<t tx="ekr.20031218072017.3852">def browser (self,n):
    
    types = [
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py"),
        ("Text files","*.txt"),
        ("All files","*") ]

    fileName = tkFileDialog.askopenfilename(
        title="Choose compare file" + n,
        filetypes=types,
        defaultextension=".txt")
        
    if fileName and len(fileName) &gt; 0:
        # The dialog also warns about this, so this may never happen.
        if not g.os_path_exists(fileName):
            self.show("not found: " + fileName)
            fileName = None
    else: fileName = None
        
    return fileName
</t>
<t tx="ekr.20031218072017.3853"></t>
<t tx="ekr.20031218072017.3854">def onBrowse1 (self):
    
    fileName = self.browser("1")
    if fileName:
        e = self.browseEntries[0]
        e.delete(0,"end")
        e.insert(0,fileName)
    self.top.deiconify()
    
def onBrowse2 (self):
    
    fileName = self.browser("2")
    if fileName:
        e = self.browseEntries[1]
        e.delete(0,"end")
        e.insert(0,fileName)
    self.top.deiconify()
    
def onBrowse3 (self): # Get the name of the output file.

    fileName = tkFileDialog.asksaveasfilename(
        initialfile = self.defaultOutputFileName,
        title="Set output file",
        filetypes=[("Text files", "*.txt")],
        defaultextension=".txt")
        
    if fileName and len(fileName) &gt; 0:
        self.defaultOutputFileName = fileName
        self.useOutputFileVar.set(1) # The user will expect this.
        e = self.browseEntries[2]
        e.delete(0,"end")
        e.insert(0,fileName)
</t>
<t tx="ekr.20031218072017.3855">def onClose (self):
    
    self.top.withdraw()
</t>
<t tx="ekr.20031218072017.3856">def onCompareDirectories (self):

    self.setIvarsFromWidgets()
    self.compare_directories(self.fileName1,self.fileName2)

def onCompareFiles (self):

    self.setIvarsFromWidgets()
    self.compare_files(self.fileName1,self.fileName2)
</t>
<t tx="ekr.20031218072017.3857">def onPrintMatchedLines (self):
    
    v = self.printMatchesVar.get()
    b = self.printButtons[1]
    state = g.choose(v,"normal","disabled")
    b.configure(state=state)
</t>
<t tx="ekr.20031218072017.3897">@language python
@tabwidth -4
@pagewidth 80

import leoGlobals as g
import leoFind

import leoTkinterDialog
import Tkinter as Tk

@others
</t>
<t tx="ekr.20031218072017.3898"></t>
<t tx="ekr.20031218072017.3899">def __init__(self,c,resizeable=False,title=None,show=True):

    # g.trace("leoTkinterFind",c)
    
    # Init the base classes...
    leoFind.leoFind.__init__(self,c,title=title)
    leoTkinterDialog.leoTkinterDialog.__init__(self,c,self.title,resizeable,show=show)

    &lt;&lt; create the tkinter intVars &gt;&gt;
    
    # These are created later.
    self.find_ctrl = None
    self.change_ctrl = None 
    
    self.createTopFrame() # Create the outer tkinter dialog frame.
    self.createFrame()
    if self.top and not show:
        self.top.withdraw()
    self.init(c) # New in 4.3: init only once.
</t>
<t tx="ekr.20031218072017.3900">self.dict = {}

for key in self.intKeys:
    self.dict[key] = Tk.IntVar()

for key in self.newStringKeys:
    self.dict[key] = Tk.StringVar()
    
self.s_ctrl = Tk.Text() # Used by find.search()
</t>
<t tx="ekr.20031218072017.3901">def destroySelf (self):
    
    self.top.destroy()
</t>
<t tx="ekr.20031218072017.3902">def createFrame (self):
    
    # g.trace('legacy')

    # Create the find panel...
    outer = Tk.Frame(self.frame,relief="groove",bd=2)
    outer.pack(padx=2,pady=2)

    &lt;&lt; Create the Find and Change panes &gt;&gt;
    &lt;&lt; Create four columns of radio and checkboxes &gt;&gt;
    &lt;&lt; Create two rows of buttons &gt;&gt;

    if self.top: # self.top may not exist during unit testing.
        self.top.protocol("WM_DELETE_WINDOW", self.onCloseWindow)
</t>
<t tx="ekr.20031218072017.3903">columnsFrame = Tk.Frame(outer,relief="groove",bd=2)
columnsFrame.pack(anchor="e",expand=1,padx="7p",pady="2p") # Don't fill.

numberOfColumns = 4 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []
for i in xrange(numberOfColumns):
    columns.append(Tk.Frame(columnsFrame,bd=1))
    radioLists.append([])
    checkLists.append([])

for i in xrange(numberOfColumns):
    columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.
    
# HotKeys used for check/radio buttons:  a,b,c,e,h,i,l,m,n,o,p,r,s,t,w

radioLists[0] = [
    (self.dict["radio-find-type"],"P&amp;Lain Search","plain-search"),  
    (self.dict["radio-find-type"],"&amp;Pattern Match Search","pattern-search"),
    (self.dict["radio-find-type"],"&amp;Script Search","script-search")]
checkLists[0] = [
    ("Scrip&amp;t Change",self.dict["script_change"])]
checkLists[1] = [
    ("&amp;Whole Word",  self.dict["whole_word"]),
    ("&amp;Ignore Case", self.dict["ignore_case"]),
    ("Wrap &amp;Around", self.dict["wrap"]),
    ("&amp;Reverse",     self.dict["reverse"])]
radioLists[2] = [
    (self.dict["radio-search-scope"],"&amp;Entire Outline","entire-outline"),
    (self.dict["radio-search-scope"],"Suboutline &amp;Only","suboutline-only"),  
    (self.dict["radio-search-scope"],"&amp;Node Only","node-only"),
    # I don't know what selection-only is supposed to do.
    (self.dict["radio-search-scope"],"Selection Only",None)] #,"selection-only")]
checkLists[2] = []
checkLists[3] = [
    ("Search &amp;Headline Text", self.dict["search_headline"]),
    ("Search &amp;Body Text",     self.dict["search_body"]),
    ("&amp;Mark Finds",           self.dict["mark_finds"]),
    ("Mark &amp;Changes",         self.dict["mark_changes"])]

for i in xrange(numberOfColumns):
    for var,name,val in radioLists[i]:
        box = underlinedTkButton("radio",columns[i],anchor="w",text=name,variable=var,value=val)
        box.button.pack(fill="x")
        box.button.bind("&lt;1&gt;", self.resetWrap)
        if val == None: box.button.configure(state="disabled")
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
    for name,var in checkLists[i]:
        box = underlinedTkButton("check",columns[i],anchor="w",text=name,variable=var)
        box.button.pack(fill="x")
        box.button.bind("&lt;1&gt;", self.resetWrap)
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
        if var is None: box.button.configure(state="disabled")</t>
<t tx="ekr.20031218072017.3904">fc = Tk.Frame(outer, bd="1m")
fc.pack(anchor="n", fill="x", expand=1)

# Removed unused height/width params: using fractions causes problems in some locales!
fpane = Tk.Frame(fc, bd=1)
cpane = Tk.Frame(fc, bd=1)

fpane.pack(anchor="n", expand=1, fill="x")
cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
flab = Tk.Label(fpane, width=8, text="Find:")
clab = Tk.Label(cpane, width=8, text="Change:")

# Use bigger boxes for scripts.
self.find_ctrl   = ftxt = Tk.Text(fpane,bd=1,relief="groove",height=4,width=20)
self.change_ctrl = ctxt = Tk.Text(cpane,bd=1,relief="groove",height=4,width=20)

&lt;&lt; Bind Tab and control-tab &gt;&gt;

fBar = Tk.Scrollbar(fpane,name='findBar')
cBar = Tk.Scrollbar(cpane,name='changeBar')

# Add scrollbars.
for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
    txt['yscrollcommand'] = bar.set
    bar['command'] = txt.yview
    bar.pack(side="right", fill="y")

flab.pack(side="left")
clab.pack(side="left")
ctxt.pack(side="right", expand=1, fill="both")
ftxt.pack(side="right", expand=1, fill="both")
</t>
<t tx="ekr.20031218072017.3905"># Create the button panes
buttons  = Tk.Frame(outer,bd=1)
buttons2 = Tk.Frame(outer,bd=1)
buttons.pack (anchor="n",expand=1,fill="x")
buttons2.pack(anchor="n",expand=1,fill="x")

# In 4.4 it's dubious to define these keys.  For example, Alt-x must be reserved!
# HotKeys used for check/radio buttons:  a,b,c,e,h,i,l,m,n,o,p,r,s,t,w
# HotKeys used for plain buttons (enter),d,g,t

def findButtonCallback(event=None,self=self):
    self.findButton()
    return 'break'

# Create the first row of buttons
findButton=Tk.Button(buttons,
    width=9,text="Find",bd=4,command=findButtonCallback) # The default.

findButton.pack(pady="1p",padx="25p",side="left")

contextBox = underlinedTkButton("check",buttons,
    anchor="w",text="Show Conte&amp;xt",variable=self.dict["batch"])
contextBox.button.pack(pady="1p",side="left",expand=1)
contextBox.bindHotKey(ftxt)
contextBox.bindHotKey(ctxt)

findAllButton = underlinedTkButton("button",buttons,
    width=9,text="Fin&amp;d All",command=self.findAllButton)
findAllButton.button.pack(pady="1p",padx="25p",side="right",fill="x")
findAllButton.bindHotKey(ftxt)
findAllButton.bindHotKey(ctxt)

# Create the second row of buttons
changeButton = underlinedTkButton("button",buttons2,
    width=10,text="Chan&amp;Ge",command=self.changeButton)
changeButton.button.pack(pady="1p",padx="25p",side="left")
changeButton.bindHotKey(ftxt)
changeButton.bindHotKey(ctxt)

changeFindButton = underlinedTkButton("button",buttons2,
    text="Change, &amp;Then Find",command=self.changeThenFindButton)
changeFindButton.button.pack(pady="1p",side="left",expand=1)
changeFindButton.bindHotKey(ftxt)
changeFindButton.bindHotKey(ctxt)
    
changeAllButton = underlinedTkButton("button",buttons2,
    width=10,text="Change All",command=self.changeAllButton)
changeAllButton.button.pack(pady="1p",padx="25p",side="right")
changeAllButton.bindHotKey(ftxt)
changeAllButton.bindHotKey(ctxt)
</t>
<t tx="ekr.20031218072017.3906">def onCloseWindow(self,event=None):
    
    __pychecker__ = '--no-argsused' # the event param must be present.

    self.top.withdraw()
</t>
<t tx="ekr.20031218072017.3907">def bringToFront (self):
    
    """Bring the tkinter Find Panel to the front."""
    
    c = self.c ; t = self.find_ctrl ; gui = g.app.gui
            
    self.top.withdraw() # Helps bring the window to the front.
    self.top.deiconify()
    self.top.lift()

    c.widgetWantsFocusNow(t)
    gui.selectAllText(t)
</t>
<t tx="ekr.20031218072017.3908">def init_s_ctrl (self,s):
    t = self.s_ctrl
    t.delete("1.0","end")
    t.insert("end",s)
    t.mark_set("insert",g.choose(self.reverse,"end","1.0"))
    return t
</t>
<t tx="ekr.20031218072017.4099">"""Tkinter keystroke handling for Leo."""

@language python
@tabwidth -4
@pagewidth 80

import leoGlobals as g
</t>
<t tx="ekr.20041025152343">class underlinedTkButton:
    
    @others
</t>
<t tx="ekr.20041025152343.1">class leoTkinterFind (leoFind.leoFind,leoTkinterDialog.leoTkinterDialog):

    """A class that implements Leo's tkinter find dialog."""

    @others
</t>
<t tx="ekr.20041025152712">def __init__(self,buttonType,parent_widget,**keywords):

    self.buttonType = buttonType
    self.parent_widget = parent_widget
    self.hotKey = None
    text = keywords['text']

    &lt;&lt; set self.hotKey if '&amp;' is in the string &gt;&gt;

    # Create the button...
    if self.hotKey:
        keywords['text'] = text
        keywords['underline'] = index

    if buttonType.lower() == "button":
        self.button = Tk.Button(parent_widget,keywords)
    elif buttonType.lower() == "check":
        self.button = Tk.Checkbutton(parent_widget,keywords)
    elif buttonType.lower() == "radio":
        self.button = Tk.Radiobutton(parent_widget,keywords)
    else:
        g.trace("bad buttonType")
    
    self.text = text # for traces
</t>
<t tx="ekr.20041025152712.2">index = text.find('&amp;')

if index &gt; -1:

    if index == len(text)-1:
        # The word ends in an ampersand.  Ignore it; there is no hot key.
        text = text[:-1]
    else:
        self.hotKey = text [index + 1]
        text = text[:index] + text[index+1:]
</t>
<t tx="ekr.20041025152717"># The hot key has been hit.  Call the button's command.

def buttonCallback (self, event=None):

    # g.trace(self.text)
    self.button.invoke ()
    
    # See if this helps.
    return 'break'
</t>
<t tx="ekr.20041026080125">def bindHotKey (self,widget):
    
    if self.hotKey:
        for key in (self.hotKey.lower(),self.hotKey.upper()):
            widget.bind("&lt;Alt-%s&gt;" % key,self.buttonCallback)
</t>
<t tx="ekr.20041026092141">def setFocus(w):
    c = self.c
    c.widgetWantsFocus(w)
    g.app.gui.setSelectionRange(w,"1.0","1.0")
    return "break"
    
def toFind(event,w=ftxt): return setFocus(w)
def toChange(event,w=ctxt): return setFocus(w)

def insertTab(w):
    data = g.app.gui.getSelectionRange(w)
    if data: start,end = data
    else: start = end = g.app.gui.getInsertPoint(w)
    g.app.gui.replaceSelectionRangeWithText(w,start,end,"\t")
    return "break"

def insertFindTab(event,w=ftxt): return insertTab(w)
def insertChangeTab(event,w=ctxt): return insertTab(w)

ftxt.bind("&lt;Tab&gt;",toChange)
ctxt.bind("&lt;Tab&gt;",toFind)
ftxt.bind("&lt;Control-Tab&gt;",insertFindTab)
ctxt.bind("&lt;Control-Tab&gt;",insertChangeTab)
</t>
<t tx="ekr.20050204090259">def adjust_find_text(self,s):
    
    w = self.find_ctrl
    
    w.delete("1.0","end")
    w.insert("end",s)
</t>
<t tx="ekr.20050721093241">@nocolor

The following are notes for anyone who is interested in writing alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.  The base classes for these gui-specific classes are in the node Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.  

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in leoPy.leo contain all of Leo's Tkinter-specific code.  Gui plugins would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4:  Gui-specific classes must implement the 'gui wrapper methods' specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific services to Leo's core.

The alternative would be to implement all gui-specific commands directly in the gui-specific code.  But this would be much more work than needed.  For example, only a few gui-specific wrappers are needed to implement all commands that deal with body text.  Implementing each of these commands 'from scratch' would duplicate a lot of code unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1.  It requires defining enough wrappers (both in the base gui classes and subclasses) so that all gui-specific services needed by Leo's core are available.   Adding a wrapper to a gui base class involves adding it to all gui-specific subclasses.  It's easy to forget to add a wrapper.  The gui base class defines all wrappers as a function that just calls oops().  This prints a warning that the wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that were defined later assume Python indices (see Rule 5 below).   The newer style wrappers that use Python indices have 'Python' in their name.   Having two sets of wrappers is one of the ugliest features of the present code.  I find it hard to remember which wrappers exist and what exactly they do :-)

Rule 5:  Leo's core should use Python indices, not gui-specific indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to len(s) (end of text s).  That is, there are exactly len(s) + 1 valid indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where text s has x lines and where the length of the last line is y-1. 

Two (recently written) functions in leoGlobals.py support conversions from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column index used by Tkinter.
- g.convertRowColToPythonIndex does the reverse.

Important:  the first Tkinter index is '1.0', not '0.0', but the row returned by g.convertPythonIndexToRowCol is zero based, so the code that actually creates Tkinter indices from row/col must add 1 to the row.  Similar remarks apply when going in the reverse direction.
</t>
<t tx="ekr.20051013084256">def dismiss (self):
    
    self.top.withdraw()
</t>
<t tx="ekr.20060207080537">def createBindings (self):
    
    # Legacy bindings.  Can be overwritten in subclasses.
    
    # g.trace('legacy')
    
    def findButtonCallback2(event,self=self):
        self.findButton()
        return 'break'

    for widget in (self.find_ctrl, self.change_ctrl):
        widget.bind ("&lt;Button-1&gt;",  self.resetWrap)
        widget.bind("&lt;Key&gt;",        self.resetWrap)
        widget.bind("&lt;Control-a&gt;",  self.selectAllFindText)
    
    for widget in (self.find_ctrl, self.change_ctrl):
        widget.bind("&lt;Key-Return&gt;", findButtonCallback2)
        widget.bind("&lt;Key-Escape&gt;", self.onCloseWindow)
</t>
<t tx="ekr.20060829084924"># Get the default body font.
defaultBodyfont = self.fonts.get('default_body_font')
if not defaultBodyfont:
    defaultBodyfont = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)
    self.fonts['default_body_font'] = defaultBodyfont

# Configure fonts.
w = c.frame.body.bodyCtrl
keys = default_font_dict.keys() ; keys.sort()
for key in keys:
    option_name = default_font_dict[key]
    # First, look for the language-specific setting, then the general setting.
    for name in ('%s_%s' % (self.language,option_name),(option_name)):
        font = self.fonts.get(name)
        if font:
            # g.trace('found',name,id(font))
            w.tag_config(key,font=font)
            break
        else:
            family = c.config.get(name + '_family','family')
            size   = c.config.get(name + '_size',  'size')   
            slant  = c.config.get(name + '_slant', 'slant')
            weight = c.config.get(name + '_weight','weight')
            if family or slant or weight or size:
                family = family or g.app.config.defaultFontFamily
                size   = size or c.config.defaultBodyFontSize
                slant  = slant or 'roman'
                weight = weight or 'normal'
                font = g.app.gui.getFontFromParams(family,size,slant,weight)
                # Save a reference to the font so it 'sticks'.
                self.fonts[name] = font 
                # g.trace(key,name,family,size,slant,weight,id(font))
                w.tag_config(key,font=font)
                break
    else: # Neither the general setting nor the language-specific setting exists.
        if len(self.fonts.keys()) &gt; 1: # Restore the default font.
            # g.trace('default',key)
            w.tag_config(key,font=defaultBodyfont)</t>
<t tx="ekr.20061024060248.1">@first # -*- coding: utf-8 -*-

&lt;&lt; docstring&gt;&gt;

@language python
@tabwidth -4

# As in leo.py we must be very careful about imports.
g = None # set by init: do *not* import it here!
inited = False

@others</t>
<t tx="ekr.20061024060248.2">'''A module to allow the Pymacs bridge to access Leo data.

All code in this module must be called *from* Emacs:
calling Pymacs.lisp in other situations will hang Leo.

Emacs code initiallizes this module with::
    
    (pymacs-eval "sys.path.append('c:\\prog\\tigris-cvs\\leo\\src')")
    (setq leo (pymacs-load "leoPymacs"))

'''
</t>
<t tx="ekr.20061024060248.3">def hello():

    init()
    return 'Hello from Leo.  g.app: %s' % g.app</t>
<t tx="ekr.20061024075542">def init ():
    
    global inited

    if inited:
        return
    else:
        inited = True
    
    # Create the dummy app
    import leo 
    leo.run(pymacs=True)
    
    import leoGlobals
    global g ; g = leoGlobals

    # These traces show up in the pymacs buffer.
    g.trace('app',g.app)
    g.trace('gui',g.app.gui)
</t>
<t tx="ekr.20061024075542.1">def open (fileName=None):
    
    init()
    
    if g.app.unitTesting:
        return
    
    if not fileName:
        g.es_print('leoPymacs.open: no file name')
        return None

    # openWithFileName checks to see if the file is already open.
    ok, frame = g.openWithFileName(
        fileName,
        old_c=None,
        enableLog=False,
        readAtFileNodesFlag=True)

    c = ok and frame.c or None
    if c:
        g.es_print('leoPymacs.open: %s' % c)
    else:
        g.es_print('leoPymacs.open: Can not open %s' % fileName)

    return c</t>
<t tx="ekr.20061024084200">def run_script(c,script,p=None):
    
    # It is possible to use script=None, in which case p must be defined.
    
    init()
    
    if c is None:
        c,frame = g.app.newLeoCommanderAndFrame(fileName='dummy script file')
            
    g.app.scriptResult = None

    c.executeScript(
        event=None,
        p=p,
        script=script,
        useSelectedText=False,
        define_g=True,
        define_name='__main__',
        silent=True,  # Don't write to the log.
    )
    
    # g.trace('script returns: ',repr(g.app.scriptResult))
    return g.app.scriptResult</t>
<t tx="ekr.20061024130957">def get_app ():
    '''Scripts can use g.app.scriptDict for communication with pymacs.'''
    init()
    return g.app
    
def get_g():
    init()
    return g
    
def script_result():
    init()
    return g.app.scriptResult</t>
<t tx="ekr.20061024131236">def dump (anObject):
    
    init()
    
    return str(g.toEncodedString(repr(anObject),encoding='ascii'))
</t>
</tnodes>
</leo_file>
